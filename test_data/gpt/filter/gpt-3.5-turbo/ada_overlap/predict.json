[{"db_id": "concert_singer", "gold": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1", "question": "Show the name and the release year of the song by the youngest singer.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: We need to find the youngest singer and retrieve the name and release year of their song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'singer' table.\n\n<3> SQL Generation: Use 'order by' to sort the singers by age in ascending order, then select the name and release year of the youngest singer.\n\n", "predict": "SELECT Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1"}, {"db_id": "concert_singer", "gold": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1", "question": "What are the names and release years for all the songs of the youngest singer?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the youngest singer. Secondly, we need to select the names and release years of all the songs by the youngest singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need information from the 'singer' and 'singer_in_concert' tables.\n\n<3> SQL Generation: Use 'select min' to find the minimum age of the singers. Then, use 'where' to filter the youngest singer. Finally, use 'select' to retrieve the names and release years of all the songs by the youngest singer.\n\n", "predict": "SELECT song_name, song_release_year FROM singer_in_concert JOIN singer ON singer_in_concert.singer_id = singer.singer_id WHERE age = (SELECT min(age) FROM singer)"}, {"db_id": "concert_singer", "gold": "SELECT DISTINCT country FROM singer WHERE age  >  20", "question": "What are all distinct countries where singers above age 20 are from?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on singers above age 20 and selecting the distinct countries they are from.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'singer' table.\n\n<3> SQL Generation: Use 'where' to filter singers above age 20, select their countries, and use 'distinct' to get unique countries.\n\n", "predict": "SELECT DISTINCT Country FROM singer WHERE Age > 20"}, {"db_id": "concert_singer", "gold": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)", "question": "List all song names by singers above the average age.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the average age of singers. Secondly, we need to filter singers whose age is above the average. Finally, we need to select the song names of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select song_name from table 'singer' and filter based on age from table 'singer'.\n\n<3> SQL Generation: Use 'where' to filter singers based on their age being above the average, and then select the song names of these singers.\n\n", "predict": "SELECT DISTINCT T1.song_name FROM singer AS T1 JOIN (SELECT AVG(age) AS avg_age FROM singer) AS T2 WHERE T1.age > T2.avg_age"}, {"db_id": "concert_singer", "gold": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)", "question": "What are all the song names by singers who are older than average?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all singers. Secondly, we need to filter singers based on their age being older than the average. Finally, we need to select the song names of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'singer' and 'singer_in_concert' tables for this query.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of all singers, and then use 'where' to filter singers with an age older than the average. Finally, select the song names of these singers.\n\n", "predict": "SELECT song_name FROM singer JOIN singer_in_concert ON singer.singer_id = singer_in_concert.singer_id WHERE age > (SELECT avg(age) FROM singer)"}, {"db_id": "concert_singer", "gold": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000", "question": "Show location and name for all stadiums with a capacity between 5000 and 10000.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on stadiums with a capacity between 5000 and 10000. We need to select the location and name for these stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select location and name from table 'stadium' where capacity is between 5000 and 10000.\n\n<3> SQL Generation: Use 'where' to filter stadiums with a capacity between 5000 and 10000, and then select the location and name.\n\n", "predict": "SELECT location, name FROM stadium WHERE capacity BETWEEN 5000 AND 10000"}, {"db_id": "concert_singer", "gold": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000", "question": "What are the locations and names of all stations with capacity between 5000 and 10000?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on stadiums with a capacity between 5000 and 10000. We need to select the locations and names of these stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'stadium' table and its 'Location' and 'Name' columns.\n\n<3> SQL Generation: We need to filter the rows in the 'stadium' table where the 'Capacity' column is between 5000 and 10000. Finally, we select the 'Location' and 'Name' columns from the 'stadium' table.\n\n", "predict": "SELECT Location, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000"}, {"db_id": "concert_singer", "gold": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1", "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter concerts that happened in 2014 or after. Secondly, we need to count the number of concerts in each stadium. Finally, we need to find the stadium with the highest number of concerts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Stadium_ID from table 'concert' where Year >= 2014. In the second step, we need to count the number of concerts in each stadium by grouping by Stadium_ID in table 'singer_in_concert'. In the final step, we need to select the stadium name and capacity from table 'stadium' based on the stadium with the highest number of concerts.\n\n<3> SQL Generation: Use 'where' to filter concerts that happened in 2014 or after. Use 'group by' and 'count' to count the number of concerts in each stadium. Use 'order by' and 'limit' to select the stadium with the highest number of concerts. Finally, select the stadium name and capacity from table 'stadium'.\n\n", "predict": "SELECT s.Name, s.Capacity FROM concert AS c JOIN stadium AS s ON c.Stadium_ID = s.Stadium_ID WHERE c.Year >= 2014 GROUP BY c.Stadium_ID ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "concert_singer", "gold": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014", "question": "List all singer names in concerts in year 2014.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: We need to filter concerts that happened in year 2014 and find the names of the singers performing in those concerts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select concert_ID from table 'concert' where Year = 2014. In the second step, we need to select Singer_ID from table 'singer_in_concert' and join it with table 'singer' to get the corresponding names.\n\n<3> SQL Generation: Use 'where' to filter concerts that happened in year 2014, and then use 'join' to connect the Singer_ID with the Singer_ID in table 'singer' to get the names of the singers.\n\n", "predict": "SELECT T2.Name FROM concert AS T1 JOIN singer_in_concert AS T3 ON T1.concert_ID = T3.concert_ID JOIN singer AS T2 ON T3.Singer_ID = T2.Singer_ID WHERE T1.Year = 2014"}, {"db_id": "concert_singer", "gold": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014", "question": "What are the names of the singers who performed in a concert in 2014?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on concerts that took place in 2014. We need to identify the singers who performed in these concerts and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of singers from the 'singer' table who performed in concerts from the 'concert' table.\n\n<3> SQL Generation: Use 'where' to filter concerts that took place in 2014, join the 'singer_in_concert' and 'singer' tables on the 'Singer_ID' column, and select the names of the singers.\n\n", "predict": "SELECT T2.Name FROM singer AS T2 JOIN singer_in_concert AS T1 ON T1.Singer_ID = T2.Singer_ID JOIN concert AS T3 ON T1.concert_ID = T3.concert_ID WHERE T3.Year = 2014"}, {"db_id": "concert_singer", "gold": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'", "question": "what is the name and nation of the singer who have a song having 'Hey' in its name?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the songs that have 'Hey' in their name. Secondly, we need to find the singers who have a song with that name and retrieve their name and nation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Singer_ID from table 'singer' where Song_Name contains 'Hey'. In the second step, we need to filter Singer_ID from table 'singer_in_concert' and retrieve the corresponding name and nation from table 'singer'.\n\n<3> SQL Generation: Use 'where' to find the songs that have 'Hey' in their name, and then use 'where' to filter singers who have a song with that name and select their name and nation.\n\n", "predict": "SELECT T2.Name ,  T2.Country FROM singer AS T2 JOIN singer_in_concert AS T1 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Song_Name LIKE '%Hey%'"}, {"db_id": "concert_singer", "gold": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'", "question": "What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the songs that have the word 'Hey' in their title. Secondly, we need to find the singers who have sung these songs. Finally, we need to return the name and country of origin of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Name and Country from table 'singer' where Song_Name contains the word 'Hey'.\n\n<3> SQL Generation: Use 'where' to find the songs that have the word 'Hey' in their title in the table 'singer'. Then, select the Name and Country of the singers who have sung these songs.\n\n", "predict": "SELECT Name, Country FROM singer WHERE Song_Name LIKE \"%Hey%\""}, {"db_id": "concert_singer", "gold": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)", "question": "Find the number of concerts happened in the stadium with the highest capacity .", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the stadium with the highest capacity. Secondly, we need to find the number of concerts that happened in that stadium.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'stadium' table to find the stadium with the highest capacity. We also need the 'concert' and 'singer_in_concert' tables to find the number of concerts happened in that stadium.\n\n<3> SQL Generation: Use 'max' function to find the stadium with the highest capacity. Then, use 'count' function to find the number of concerts happened in that stadium.\n\n", "predict": "SELECT COUNT(*) FROM concert WHERE Stadium_ID = (SELECT Stadium_ID FROM stadium WHERE Capacity = (SELECT MAX(Capacity) FROM stadium))"}, {"db_id": "concert_singer", "gold": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)", "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "<1> Decomposition: The query requires finding the stadium with the largest capacity and then counting the number of concerts that occurred in that stadium.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'stadium' table to find the stadium with the largest capacity and the 'concert' table to count the number of concerts.\n\n<3> SQL Generation: Use 'order by' and 'limit' to find the stadium with the largest capacity. Then, use 'where' to filter the concerts that occurred in that stadium and count them.\n\n", "predict": "SELECT COUNT(*) FROM concert WHERE Stadium_ID = (SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1)"}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM pets WHERE weight  >  10", "question": "Find the number of pets whose weight is heavier than 10.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: We need to find the pets whose weight is heavier than 10.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Pets' table to get the weight of the pets.\n\n<3> SQL Generation: Use 'where' to filter the pets whose weight is heavier than 10, and then use 'count' to count the number of pets.\n\n", "predict": "SELECT count(*) FROM Pets WHERE weight > 10"}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM pets WHERE weight  >  10", "question": "How many pets have a greater weight than 10?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the pets with a weight greater than 10. Secondly, we need to count the number of pets that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'weight' column from the 'Pets' table, we only need the 'Pets' table.\n\n<3> SQL Generation: Use 'where' to filter pets with a weight greater than 10, and then use 'count' to count the number of pets.\n\n", "predict": "SELECT count(*) FROM pets WHERE weight > 10"}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20", "question": "Find number of pets owned by students who are older than 20.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their age. Secondly, we need to find the pets owned by those students. Finally, we need to count the number of pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the StuID from the table 'Student' where the Age is greater than 20. In the second step, we need to select the PetID from the table 'Has_Pet' where the StuID matches the one found in the first step. In the final step, we need to count the number of pets from the table 'Pets' where the PetID matches the ones found in the second step.\n\n<3> SQL Generation: Use 'where' to filter students based on age, then use 'where' to find the pets owned by those students, and finally use 'count' to count the number of pets.\n\n", "predict": "SELECT count(*) FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID  =  T2.StuID JOIN Pets AS T3 ON T3.PetID  =  T2.PetID WHERE T1.Age  >  20"}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20", "question": "How many pets are owned by students that have an age greater than 20?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students with an age greater than 20. Secondly, we need to filter the pets owned by these students. Finally, we need to count the number of pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where Age > 20. In the second step, we need to filter PetID from table 'Has_Pet' based on the ownership by the selected students. In the final step, we need to count the number of pets.\n\n<3> SQL Generation: Use 'where' to find the students with an age greater than 20, and then use 'where' to filter the pets owned by these students. Finally, use 'count' to count the number of pets.\n\n", "predict": "SELECT COUNT(*) FROM Has_Pet WHERE StuID IN (SELECT StuID FROM Student WHERE Age > 20)"}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'", "question": "Find the number of dog pets that are raised by female students (with sex F).", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the pets that are dogs. Secondly, we need to filter the students who are female. Finally, we need to count the number of dog pets raised by female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select PetID from table 'Pets' where PetType = \"dog\". In the second step, we need to select StuID from table 'Student' where Sex = \"F\". In the final step, we need to count the number of PetID from table 'Has_Pet' where PetID matches the PetID found in the first step and StuID matches the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to filter the pets that are dogs, 'where' to filter the students who are female, and 'count' to count the number of dog pets raised by female students.\n\n", "predict": "SELECT COUNT(*) FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID JOIN Student AS T3 ON T1.StuID = T3.StuID WHERE T2.PetType = \"dog\" AND T3.Sex = \"F\""}, {"db_id": "pets_1", "gold": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'", "question": "How many dog pets are raised by female students?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of dog pets raised by female students. Firstly, we need to filter the pets based on their type. Secondly, we need to filter the students based on their gender. Lastly, we need to count the number of pets that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the PetID from the 'Pets' table and filter based on the PetType. We also need to select the StuID from the 'Student' table and filter based on the Sex.\n\n<3> SQL Generation: Use 'where' to filter pets with PetType = \"dog\" and students with Sex = \"female\". Then, use 'count' to count the number of pets.\n\n", "predict": "SELECT count(*) FROM Has_Pet \nJOIN Pets ON Has_Pet.PetID = Pets.PetID \nJOIN Student ON Has_Pet.StuID = Student.StuID \nWHERE Pets.PetType = \"dog\" AND Student.Sex = \"female\""}, {"db_id": "pets_1", "gold": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1", "question": "Find the type and weight of the youngest pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: We need to find the youngest pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the type and weight from the 'Pets' table and filter by the youngest pet.\n\n<3> SQL Generation: Use 'order by' to sort the pets by age in ascending order, and then select the type and weight of the youngest pet.\n\n", "predict": "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1"}, {"db_id": "pets_1", "gold": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1", "question": "Find the id and weight of all pets whose age is older than 1.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter pets whose age is older than 1. Then, we need to select their id and weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select id and weight from table 'Pets' and filter based on the age.\n\n<3> SQL Generation: Use 'where' to filter pets whose age is older than 1, and then select their id and weight.\n\n", "predict": "SELECT PetID, weight FROM Pets WHERE pet_age > 1"}, {"db_id": "pets_1", "gold": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1", "question": "What is the id and weight of every pet who is older than 1?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter pets based on their age being older than 1. Secondly, we need to select the id and weight of the filtered pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Pets' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter pets based on their age being older than 1, and then select the id and weight of the filtered pets.\n\n", "predict": "SELECT PetID, weight FROM Pets WHERE pet_age > 1"}, {"db_id": "pets_1", "gold": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid", "question": "Find the first name and age of students who have a pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who have a pet. Secondly, we need to retrieve their first name and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Has_Pet' to find the students who have a pet. Then, we can filter the corresponding first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the students who have a pet, and then select their first name and age.\n\n", "predict": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet)"}, {"db_id": "pets_1", "gold": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid", "question": "What are the different first names and ages of the students who do have pets?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who have pets. Secondly, we need to retrieve their first names and ages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name and age from the 'Student' table and filter by the students who have pets using the 'Has_Pet' table.\n\n<3> SQL Generation: Use 'join' to link the 'Student' and 'Has_Pet' tables on the 'StuID' column. Then, select the first name and age of the students.\n\n", "predict": "SELECT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID"}, {"db_id": "pets_1", "gold": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'", "question": "Find the id of the pet owned by student whose last name is \u2018Smith\u2019.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the student with the last name 'Smith'. Secondly, we need to find the pet owned by this student. Finally, we need to select the id of the pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for the pet owned by a specific student, we need to select the 'PetID' from the 'Has_Pet' table.\n\n<3> SQL Generation: Use 'where' to find the student with the last name 'Smith', and then use 'where' to filter the pet owned by this student and select its id.\n\n", "predict": "SELECT PetID FROM HAS_PET AS T1 JOIN STUDENT AS T2 ON T1.StuID  =  T2.StuID WHERE T2.LName  =  'Smith'"}, {"db_id": "pets_1", "gold": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'", "question": "What is the id of the pet owned by the student whose last name is 'Smith'?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: The query requires finding the pet owned by a student with the last name 'Smith' and retrieving its id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'Has_Pet' table with the 'Student' table and the 'Pets' table to get the desired information.\n\n<3> SQL Generation: Use 'where' to filter students with the last name 'Smith', join the 'Has_Pet' table with the 'Pets' table using the common 'PetID' column, and select the 'PetID' column.\n\n", "predict": "SELECT PetID FROM Has_Pet JOIN Student ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Student.LName = 'Smith'"}, {"db_id": "pets_1", "gold": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1", "question": "Find the first name and gender of student who have more than one pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: We need to filter students who have more than one pet and retrieve their first name and gender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first name and gender from table 'Student' and filter by the number of pets.\n\n<3> SQL Generation: Use 'where' to filter students with more than one pet, and then select their first name and gender.\n\n", "predict": "SELECT fname ,  sex FROM student WHERE stuid IN (SELECT stuid FROM has_pet GROUP BY stuid HAVING COUNT(*) > 1)"}, {"db_id": "pets_1", "gold": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1", "question": "What is the first name and gender of the all the students who have more than one pet?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: We need to filter students based on the number of pets they have, specifically those with more than one pet. Then, we need to retrieve their first name and gender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first name and gender from table 'Student' and filter by the number of pets.\n\n<3> SQL Generation: Use 'where' to filter students with more than one pet, and then select their first name and gender.\n\n", "predict": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet GROUP BY StuID HAVING COUNT(PetID) > 1)"}, {"db_id": "pets_1", "gold": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'", "question": "Find the last name of the student who has a cat that is age 3.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the PetID of the cat that is age 3. Secondly, we need to find the StuID of the student who has that PetID. Finally, we need to retrieve the last name of that student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select PetID from table 'Pets' where PetType = 'cat' and pet_age = 3. In the second step, we need to select StuID from table 'Has_Pet' where PetID matches the PetID found in the first step. In the final step, we need to retrieve the last name of the student from table 'Student' based on the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the PetID of the cat that is age 3, then use 'where' to find the StuID of the student who has that PetID, and finally select the last name of that student.\n\n", "predict": "SELECT lname FROM student WHERE stuid IN (SELECT stuid FROM has_pet WHERE petid IN (SELECT petid FROM pets WHERE pettype = 'cat' AND pet_age = 3))"}, {"db_id": "pets_1", "gold": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'", "question": "What is the last name of the student who has a cat that is 3 years old?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the student who has a cat. Secondly, we need to filter out the cats that are not 3 years old. Finally, we need to retrieve the last name of the student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select LName from table 'Student' and filter it based on the StuID in table 'Has_Pet'. Then, we need to filter the cats based on the PetType and pet_age in table 'Pets'.\n\n<3> SQL Generation: Use 'inner join' to combine the 'Student' and 'Has_Pet' tables based on the StuID, and then use 'inner join' to combine the result with the 'Pets' table based on the PetID. Use 'where' to filter the PetType as 'cat' and pet_age as 3, and then select the LName.\n\n", "predict": "SELECT LName FROM Student INNER JOIN Has_Pet ON Student.StuID = Has_Pet.StuID INNER JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = 'cat' AND pet_age = 3"}, {"db_id": "pets_1", "gold": "select avg(age) from student where stuid not in (select stuid from has_pet)", "question": "What is the average age for all students who do not own any pets ?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter out the students who do not own any pets. Secondly, we need to calculate the average age for the selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'Has_Pet' table with the 'Student' table on the 'StuID' column. Then, we can filter the rows where the 'PetID' is null and select the 'Age' column from the 'Student' table.\n\n<3> SQL Generation: Use 'join' to link the 'Has_Pet' and 'Student' tables on the 'StuID' column. Then, use 'where' to filter the rows where the 'PetID' is null. Finally, calculate the average age for the selected students.\n\n", "predict": "SELECT avg(Age) FROM Student LEFT JOIN Has_Pet ON Student.StuID = Has_Pet.StuID WHERE Has_Pet.PetID IS NULL"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "question": "Which model of the car has the minimum horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the minimum horsepower among all car models. Secondly, we need to retrieve the model of the car with the minimum horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Model from table 'car_names' and retrieve the Horsepower from table 'cars_data'.\n\n<3> SQL Generation: Use 'min' to find the minimum horsepower among all car models, and then select the model of the car with the minimum horsepower.\n\n", "predict": "SELECT Model FROM car_names WHERE MakeId IN (SELECT Id FROM cars_data WHERE Horsepower = (SELECT MIN(Horsepower) FROM cars_data))"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "question": "What is the model of the car with the smallest amount of horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the car with the smallest amount of horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the model from the 'model_list' table and filter by the smallest amount of horsepower from the 'cars_data' table.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum value of 'Horsepower' in the 'cars_data' table and then select the corresponding car model from the 'model_list' table.\n\n", "predict": "SELECT Model FROM model_list JOIN car_names ON model_list.ModelId = car_names.MakeId JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY Horsepower ASC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "question": "Find the model of the car whose weight is below the average weight.", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average weight of all cars. Secondly, we need to filter cars based on their weight being below the average. Finally, we need to select the model of the filtered cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Model' column from the 'car_names' table and filter by the weight of the cars in the 'cars_data' table.\n\n<3> SQL Generation: Use 'select' and 'avg' to calculate the average weight of all cars. Then, use 'where' to filter cars with a weight below the average and select their model.\n\n", "predict": "SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Weight < (SELECT avg(Weight) FROM cars_data)"}, {"db_id": "car_1", "gold": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "question": "What is the model for the car with a weight smaller than the average?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average weight of all cars. Secondly, we need to filter cars based on their weight being smaller than the average. Lastly, we need to retrieve the model of the filtered cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the model from table 'model_list' for the filtered cars.\n\n<3> SQL Generation: Use 'avg' to calculate the average weight of all cars, and then use 'where' to filter cars with a weight smaller than the average. Finally, select the model from table 'model_list' for the filtered cars.\n\n", "predict": "SELECT model_list.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model WHERE cars_data.Weight < (SELECT avg(Weight) FROM cars_data)"}, {"db_id": "car_1", "gold": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';", "question": "Find the name of the makers that produced some cars in the year of 1970?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cars that were produced in the year 1970. Secondly, we need to find the makers of these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Year = 1970. In the second step, we need to select Maker from table 'car_makers' where Id matches the Id of the selected cars.\n\n<3> SQL Generation: Use 'where' to find the cars that were produced in the year 1970, and then use 'where' to find the makers of these cars.\n\n", "predict": "SELECT DISTINCT T2.Maker FROM cars_data AS T1 JOIN car_makers AS T2 ON T1.Id = T2.Id WHERE T1.Year = 1970"}, {"db_id": "car_1", "gold": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';", "question": "What is the name of the different car makers who produced a car in 1970?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car makers who produced a car in 1970. Secondly, we need to retrieve the names of those car makers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Maker column from the car_makers table, join it with the model_list table on the Id column, join it with the car_names table on the Model column, and join it with the cars_data table on the MakeId column. Then, we need to filter the cars_data table by the Year column to only include cars produced in 1970.\n\n<3> SQL Generation: Use 'where' to filter cars produced in 1970, join the necessary tables, and select the distinct Maker column from the car_makers table.\n\n", "predict": "SELECT DISTINCT car_makers.Maker FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE cars_data.Year = 1970"}, {"db_id": "car_1", "gold": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "question": "Find the make and production time of the cars that were produced in the earliest year?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the cars that were produced in the earliest year. Then, we need to retrieve their make and production time.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the make and production time from the 'car_makers' and 'cars_data' tables.\n\n<3> SQL Generation: Use 'where' to filter the cars that were produced in the earliest year, and then select their make and production time.\n\n", "predict": "SELECT car_makers.maker, cars_data.year FROM car_makers JOIN car_names ON car_makers.id = car_names.makeid JOIN cars_data ON car_names.makeid = cars_data.id WHERE cars_data.year = (SELECT MIN(year) FROM cars_data)"}, {"db_id": "car_1", "gold": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "question": "Which distinct car models are the produced after 1980?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter car models that were produced after 1980. Secondly, we need to retrieve the distinct car models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'car_makers', 'model_list', 'car_names', and 'cars_data' tables to filter and retrieve the car models.\n\n<3> SQL Generation: Use 'where' to filter car models that were produced after 1980, and then use 'distinct' to retrieve the distinct car models.\n\n", "predict": "SELECT DISTINCT car_names.Model FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.ModelId = car_names.MakeId JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE cars_data.Year > 1980"}, {"db_id": "car_1", "gold": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "question": "What are the different models for the cards produced after 1980?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the cars that were produced after 1980. Secondly, we need to retrieve the different models of these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'cars_data', 'car_names', and 'model_list' on the corresponding foreign keys.\n\n<3> SQL Generation: Use 'join' to combine the tables based on the foreign key relationships. Then, use 'where' to filter the rows where the production year is after 1980. Finally, select the distinct models from the resulting rows.\n\n", "predict": "SELECT DISTINCT T3.Model FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId JOIN model_list AS T3 ON T2.Model = T3.Model WHERE T1.Year > 1980"}, {"db_id": "car_1", "gold": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car make with the name \"amc hornet sportabout (sw)\". Secondly, we need to retrieve the accelerate value of this car make.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the accelerate value from the 'cars_data' table based on the car make name.\n\n<3> SQL Generation: Use 'where' to find the car make with the name \"amc hornet sportabout (sw)\", and then select the corresponding accelerate value.\n\n", "predict": "SELECT Accelerate FROM cars_data WHERE Id = (SELECT MakeId FROM car_names WHERE Model = 'amc hornet sportabout (sw)')"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "question": "How many car makers are there in france?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of car makers in France.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the car makers from the 'car_makers' table where the country is 'France'.\n\n<3> SQL Generation: Use 'where' to filter the car makers in France and count them.\n\n", "predict": "SELECT count(*) FROM car_makers WHERE country  =  \"France\""}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "question": "What is the number of makers of care in France?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to filter car makers based on their country, specifically France.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'car_makers' table and the 'Country' column.\n\n<3> SQL Generation: Use 'where' to filter car makers based on their country being France, and then count the number of rows that meet this condition.\n\n", "predict": "SELECT COUNT(*) FROM car_makers WHERE Country = 'France'"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "question": "How many car models are produced in the usa?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter car models that are produced in the USA. Secondly, we need to count the number of unique car models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to filter by the country name 'USA' in the 'countries' table. Then, we need to join the 'car_makers' table with the 'model_list' table to get the car models produced by the USA.\n\n<3> SQL Generation: Use 'where' to filter car models produced in the USA, and then use 'count' to count the number of unique car models.\n\n", "predict": "SELECT COUNT(DISTINCT Model) FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker JOIN countries AS T3 ON T1.Country = T3.CountryId WHERE T3.CountryName = \"USA\""}, {"db_id": "car_1", "gold": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "question": "What is the count of the car models produced in the United States?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on car models produced in the United States. We need to count the number of car models that have the country of production as the United States.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to consider the 'car_makers' table to get the car maker IDs for car models produced in the United States. Then, we need to join the 'model_list' table to get the model IDs for those car makers. Finally, we need to join the 'car_names' table to get the count of car models.\n\n<3> SQL Generation: Use 'where' to filter car makers that have the country as the United States, join the 'model_list' table to get the model IDs, and then join the 'car_names' table to get the count of car models.\n\n", "predict": "SELECT COUNT(*) FROM car_makers AS t1 JOIN model_list AS t2 ON t1.id = t2.maker JOIN car_names AS t3 ON t2.model = t3.model WHERE t1.country = \"United States\""}, {"db_id": "car_1", "gold": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;", "question": "What is the average miles per gallon(mpg) of the cars with 4 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter cars with 4 cylinders. Secondly, we need to calculate the average miles per gallon (mpg) of these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Cylinders = 4. In the second step, we need to select MPG from table 'cars_data' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter cars with 4 cylinders, and then use 'avg' to calculate the average miles per gallon (mpg).\n\n", "predict": "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"}, {"db_id": "car_1", "gold": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;", "question": "What is the average miles per gallon of all the cards with 4 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the cars with 4 cylinders. Secondly, we need to calculate the average miles per gallon of these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Cylinders = 4. In the second step, we need to select MPG from table 'cars_data' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter the cars with 4 cylinders, and then use 'avg' to calculate the average miles per gallon.\n\n", "predict": "SELECT avg(MPG) FROM cars_data WHERE Cylinders = 4"}, {"db_id": "car_1", "gold": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974", "question": "What is the smallest weight of the car produced with 8 cylinders on 1974 ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the car produced with 8 cylinders in 1974 and then identify the smallest weight of that car.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the weight from the 'cars_data' table where cylinders = 8 and year = 1974.\n\n<3> SQL Generation: Use 'where' to filter the cars with 8 cylinders and year = 1974, and then use 'MIN' function to find the smallest weight.\n\n", "predict": "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974"}, {"db_id": "car_1", "gold": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974", "question": "What is the minimum weight of the car with 8 cylinders produced in 1974 ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car with 8 cylinders produced in 1974. Secondly, we need to calculate the minimum weight of this car.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Cylinders = 8 and Year = 1974. In the second step, we need to select Weight from table 'cars_data' where Id matches the Id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the car with 8 cylinders produced in 1974, and then use 'where' to filter the weight of this car and calculate the minimum value.\n\n", "predict": "SELECT min(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;", "question": "What are the countries having at least one car maker? List name and id.", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the countries that have at least one car maker. We need to retrieve the name and id of these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'car_makers' and 'countries' on the corresponding foreign keys.\n\n<3> SQL Generation: Use 'join' to combine the tables based on the foreign key relationships. Then, use 'group by' and 'having' to filter the countries that have at least one car maker. Finally, select the name and id of these countries.\n\n", "predict": "SELECT countries.CountryName, countries.CountryId FROM car_makers JOIN countries ON car_makers.Country = countries.CountryId GROUP BY countries.CountryName, countries.CountryId HAVING COUNT(car_makers.Id) >= 1"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;", "question": "What are the names and ids of all countries with at least one car maker?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the countries that have at least one car maker and select their names and ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the CountryId and CountryName from the 'countries' table where there is a corresponding car maker in the 'car_makers' table.\n\n<3> SQL Generation: Use 'where' to find the CountryId of the countries that have at least one car maker, and then select the CountryName and CountryId from the 'countries' table.\n\n", "predict": "SELECT CountryId, CountryName FROM countries WHERE CountryId IN (SELECT DISTINCT Country FROM car_makers)"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;", "question": "What is the number of the cars with horsepower more than 150?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with horsepower more than 150. We need to count the number of cars that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'cars_data' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cars with horsepower more than 150, and then use 'count' to calculate the total number of cars that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Horsepower > 150"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;", "question": "What is the number of cars with a horsepower greater than 150?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with a horsepower greater than 150. We need to select cars based on their horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'cars_data' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cars based on their horsepower and count the number of cars that meet the condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Horsepower > 150"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "Which countries in europe have at least 3 car manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the countries in Europe. Secondly, we need to find the car manufacturers in those countries. Finally, we need to filter the countries that have at least 3 car manufacturers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CountryId from table 'countries' where Continent = \"Europe\". In the second step, we need to filter Id from table 'car_makers' and select the corresponding Country from table 'countries'. \n\n<3> SQL Generation: Use 'where' to find the CountryId of the countries in Europe, and then use 'where' to filter the Id from table 'car_makers'. Finally, use 'group by' and 'having' to select the countries that have at least 3 car manufacturers.\n\n", "predict": "SELECT t2.CountryName FROM countries AS t1 JOIN car_makers AS t2 ON t1.CountryId = t2.Id WHERE t1.Continent = \"Europe\" GROUP BY t2.CountryName HAVING COUNT(t2.Id) >= 3"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "What are the names of all European countries with at least 3 manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the European countries. Secondly, we need to filter the countries based on having at least 3 manufacturers. Finally, we need to select the names of these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the CountryId from the \"countries\" table where the Continent is \"Europe\". In the second step, we need to count the number of manufacturers for each country using the \"car_makers\" table. In the final step, we need to select the names of the countries from the \"countries\" table.\n\n<3> SQL Generation: Use 'where' to find the CountryId of the European countries, then use 'group by' and 'having' to filter the countries based on having at least 3 manufacturers, and finally use 'select' to retrieve the names of these countries.\n\n", "predict": "SELECT countryname FROM countries AS t1 JOIN car_makers AS t2 ON t1.countryid  =  t2.country JOIN continents AS t3 ON t1.continent  =  t3.contid WHERE t3.continent  =  \"Europe\" GROUP BY t1.countryname HAVING COUNT(t2.id) >= 3"}, {"db_id": "car_1", "gold": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the models with 3 cylinders. Secondly, we need to identify the model with the largest amount of horsepower among these models. Finally, we need to retrieve the make of this model.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the models with 3 cylinders from table 'cars_data'. In the second step, we need to find the model with the largest amount of horsepower among these models. In the final step, we need to retrieve the make of this model from table 'model_list'.\n\n<3> SQL Generation: Use 'where' to find the models with 3 cylinders, and then use 'max' to find the largest amount of horsepower among these models. Finally, use 'join' to retrieve the make of the model with the largest amount of horsepower.\n\n", "predict": "SELECT model_list.Maker, MAX(cars_data.Horsepower) FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model WHERE cars_data.Cylinders = 3 GROUP BY model_list.Maker"}, {"db_id": "car_1", "gold": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';", "question": "What is the average edispl of the cars of model volvo?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the cars of model 'volvo'. Secondly, we need to calculate the average 'edispl' of these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select 'MakeId' from table 'car_names' where 'Model' = 'volvo'. In the second step, we need to select 'Edispl' from table 'cars_data' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter the cars of model 'volvo', and then use 'avg' to calculate the average 'edispl'.\n\n", "predict": "SELECT avg(T2.Edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"}, {"db_id": "car_1", "gold": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';", "question": "What is the average edispl for all volvos?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars that are volvos. Firstly, we need to identify the cars that are volvos. Secondly, we need to calculate the average edispl for those volvos.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'car_makers' where Maker is 'Volvo'. In the second step, we need to select edispl from table 'cars_data' and filter by Id.\n\n<3> SQL Generation: Use 'where' to filter cars that are volvos, and then calculate the average edispl for those volvos.\n\n", "predict": "SELECT avg(Edispl) FROM cars_data WHERE Id IN (SELECT MakeId FROM car_names WHERE Model IN (SELECT Model FROM model_list WHERE Maker IN (SELECT Id FROM car_makers WHERE Maker = 'Volvo')))"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;", "question": "How many cars have more than 4 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with more than 4 cylinders. We need to select cars based on their cylinder value.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'cars_data' table and the 'Cylinders' column.\n\n<3> SQL Generation: Use 'where' to filter cars with more than 4 cylinders and count them.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Cylinders  >  4"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;", "question": "What is the number of cars with more than 4 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with more than 4 cylinders. We need to count the number of cars that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'cars_data' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cars with more than 4 cylinders, and then use 'count' to calculate the total number of cars that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Cylinders > 4"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';", "question": "What is the number of car models created by the car maker American Motor Company?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car maker with the name \"American Motor Company\". Secondly, we need to count the number of car models created by that car maker.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the car maker with the name \"American Motor Company\" from the 'car_makers' table. Then, we need to count the number of car models from the 'model_list' table.\n\n<3> SQL Generation: Use 'where' to find the car maker with the name \"American Motor Company\", and then use 'count' to calculate the number of car models created by that car maker.\n\n", "predict": "SELECT COUNT(*) FROM model_list WHERE Maker = 'American Motor Company'"}, {"db_id": "car_1", "gold": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "question": "Which makers designed more than 3 car models? List full name and the id.", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to count the number of car models designed by each maker. Secondly, we need to filter out the makers who have designed more than 3 car models. Finally, we need to retrieve their full name and id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Maker and Id from table 'car_makers' and count(Model) from table 'model_list'. We also need to join the tables 'car_makers' and 'model_list' on the column 'Id' in 'car_makers' and 'Maker' in 'model_list'.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of car models designed by each maker and filter out the makers who have designed more than 3 car models. Finally, select their full name and id.\n\n", "predict": "SELECT car_makers.FullName, car_makers.Id FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker GROUP BY car_makers.Id HAVING COUNT(model_list.Model) > 3"}, {"db_id": "car_1", "gold": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "question": "What are the names and ids of all makers with more than 3 models?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on makers with more than 3 models. Firstly, we need to identify the makers who have more than 3 models. Secondly, we need to retrieve their names and ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the number of models for each maker, we need to use the 'car_makers' and 'model_list' tables.\n\n<3> SQL Generation: Use 'where' to filter makers with more than 3 models and select their names and ids.\n\n", "predict": "SELECT T1.Id, T1.Maker FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker GROUP BY T1.Id, T1.Maker HAVING COUNT(T2.ModelId) > 3"}, {"db_id": "car_1", "gold": "select distinct year from cars_data where weight between 3000 and 4000;", "question": "In which years cars were produced weighing no less than 3000 and no more than 4000 ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to filter cars based on their weight, specifically those weighing no less than 3000 and no more than 4000. Then, we need to retrieve the years in which these cars were produced.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Year column from the cars_data table.\n\n<3> SQL Generation: Use 'where' to filter cars with weight no less than 3000 and no more than 4000, and then select the corresponding years.\n\n", "predict": "SELECT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000"}, {"db_id": "car_1", "gold": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;", "question": "What is the horsepower of the car with the largest accelerate?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to find the car with the largest accelerate and retrieve its horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Horsepower' column from the 'cars_data' table.\n\n<3> SQL Generation: We can use the 'MAX' function to find the maximum value of 'Accelerate' in the 'cars_data' table and then select the corresponding car's horsepower.\n\n", "predict": "SELECT Horsepower FROM cars_data ORDER BY Accelerate DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car with the model \"volvo\". Secondly, we need to identify the car with the least acceleration among those cars. Lastly, we need to determine the number of cylinders in that car.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the car_id from table 'car_names' where the model is \"volvo\". Then, we need to select the car_id, cylinders, and acceleration from table 'cars_data' and filter by the car_id obtained in the previous step.\n\n<3> SQL Generation: Use 'where' to find the car with the model \"volvo\", and then use 'order by' and 'limit' to identify the car with the least acceleration. Finally, select the number of cylinders from that car.\n\n", "predict": "SELECT cylinders FROM cars_data WHERE id IN (SELECT makeid FROM car_names WHERE model = \"volvo\") ORDER BY accelerate ASC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the model_id of the Volvo model. Secondly, we need to find the version with the least acceleration for that model. Finally, we need to determine the number of cylinders for that version.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'car_makers' where Maker = 'Volvo'. In the second step, we need to filter MakeId and Accelerate from table 'cars_data' where Id is the model_id obtained in the first step. In the third step, we need to select the minimum Accelerate value from the filtered data. Finally, we need to filter Cylinders from table 'cars_data' where MakeId is the model_id obtained in the first step and Accelerate is the minimum value obtained in the previous step.\n\n<3> SQL Generation: Use 'where' to find the model_id of the Volvo model, then use 'where' and 'min' to find the version with the least acceleration for that model, and finally use 'where' to filter the number of cylinders for that version.\n\n", "predict": "SELECT Cylinders FROM cars_data WHERE MakeId = (SELECT Id FROM car_makers WHERE Maker = 'Volvo') AND Accelerate = (SELECT min(Accelerate) FROM cars_data WHERE Id = (SELECT Id FROM car_makers WHERE Maker = 'Volvo'))"}, {"db_id": "car_1", "gold": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "question": "How many cars have a larger accelerate than the car with the largest horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the car with the largest horsepower. Secondly, we need to compare the accelerate of each car with the accelerate of the car with the largest horsepower. Finally, we need to count the number of cars that have a larger accelerate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Horsepower' and 'Accelerate' columns from the 'cars_data' table.\n\n<3> SQL Generation: Use 'max' to find the car with the largest horsepower, and then use 'where' to filter cars with a larger accelerate than the car with the largest horsepower. Finally, count the number of cars that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Accelerate > (SELECT max(Horsepower) FROM cars_data)"}, {"db_id": "car_1", "gold": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "question": "How many countries has more than 2 car makers ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of countries that have more than 2 car makers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to consider the 'countries' table and the 'car_makers' table.\n\n<3> SQL Generation: We need to join the 'countries' table with the 'car_makers' table using the foreign key relationship. Then, we group the result by country and count the number of car makers for each country. Finally, we filter the result to only include countries with more than 2 car makers.\n\n", "predict": "SELECT COUNT(*) FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryId HAVING COUNT(car_makers.Id) > 2"}, {"db_id": "car_1", "gold": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "question": "What is the number of countries with more than 2 car makers ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries with more than 2 car makers. Secondly, we need to count the number of countries that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select CountryName from table 'countries' where there are more than 2 corresponding entries in table 'car_makers'.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter countries with more than 2 car makers, and then use 'count' to calculate the number of countries that meet this condition.\n\n", "predict": "SELECT count(*) FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryName HAVING count(*) > 2"}, {"db_id": "car_1", "gold": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;", "question": "How many cars has over 6 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with over 6 cylinders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'cars_data' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cars with over 6 cylinders, and then count the number of cars that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Cylinders > 6"}, {"db_id": "car_1", "gold": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;", "question": "What is the number of carsw ith over 6 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cars with over 6 cylinders. We need to select cars based on the number of cylinders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'cars_data' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cars based on the number of cylinders and count the number of cars that meet the condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Cylinders > 6"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the cars with 4 cylinders. Secondly, we need to find the model with the largest horsepower among these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the car names with 4 cylinders from table 'cars_data'. In the second step, we need to find the model with the largest horsepower from table 'car_names' based on the filtered car names.\n\n<3> SQL Generation: Use 'where' to filter the cars with 4 cylinders, and then use 'order by' and 'desc' to select the model with the largest horsepower.\n\n", "predict": "SELECT T2.Model FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T1.Cylinders = 4 ORDER BY T1.Horsepower DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the cars that have 4 cylinders. Secondly, we need to find the model with the highest horsepower among these cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the model from table 'model_list' and filter by the number of cylinders from table 'cars_data'. Then, we need to retrieve the horsepower from table 'cars_data'.\n\n<3> SQL Generation: Use 'where' to filter the cars with 4 cylinders, 'order by' and 'limit' to find the model with the highest horsepower.\n\n", "predict": "SELECT model_list.Model FROM model_list JOIN car_names ON model_list.ModelId = car_names.Model JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE cars_data.Cylinders = 4 ORDER BY cars_data.Horsepower DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3;", "question": "Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: We need to filter cars based on their horsepower, specifically those with more than the lowest horsepower. Then, we need to filter further to find cars that do not have more than 3 cylinders. Finally, we need to retrieve the car makeid and make name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select makeid and make from table 'car_names' and filter based on horsepower and cylinders from table 'cars_data'.\n\n<3> SQL Generation: Use 'where' to filter cars with horsepower greater than the lowest horsepower, and then use 'and' to filter further based on the number of cylinders. Finally, select makeid and make.\n\n", "predict": "SELECT MakeId, Make FROM car_names WHERE Horsepower > (SELECT MIN(Horsepower) FROM cars_data) AND Cylinders <= 3"}, {"db_id": "car_1", "gold": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980", "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter cars with 8 cylinders. Secondly, we need to filter cars produced before 1980. Finally, we need to find the maximum miles per gallon of the filtered cars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select MPG from table 'cars_data' and filter by Cylinders and Year.\n\n<3> SQL Generation: Use 'where' to filter cars with 8 cylinders or produced before 1980, and then find the maximum MPG.\n\n", "predict": "SELECT MAX(MPG) FROM cars_data WHERE Cylinders  =  8 OR Year  <  1980"}, {"db_id": "car_1", "gold": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;", "question": "What are the names of the countries with no car makers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires finding the countries that have no car makers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select CountryName from table 'countries' where there is no corresponding entry in the 'car_makers' table.\n\n<3> SQL Generation: Use 'where not exists' to find the countries that have no car makers, and then select the names of those countries.\n\n", "predict": "SELECT CountryName FROM countries WHERE CountryId NOT IN (SELECT Country FROM car_makers)"}, {"db_id": "car_1", "gold": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find car makers that produce at least 2 models. Secondly, we need to filter car makers that have more than 3 car makers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Id and Maker columns from the car_makers table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter car makers that produce at least 2 models, and then use 'where' to filter car makers that have more than 3 car makers.\n\n", "predict": "SELECT Id, Maker FROM car_makers WHERE Id IN (SELECT Maker FROM model_list GROUP BY Maker HAVING COUNT(*) >= 2) AND Id IN (SELECT Maker FROM car_makers GROUP BY Maker HAVING COUNT(*) > 3)"}, {"db_id": "car_1", "gold": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on car makers that produce at least 2 models and make more than 3 cars. We need to select the ids and makers of these car makers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'car_makers' table with the 'model_list' table and the 'car_names' table to get the number of models and the 'cars_data' table to get the number of cars.\n\n<3> SQL Generation: Use 'join' to link the necessary tables, 'group by' to group the results by car maker, 'having' to filter on the conditions of at least 2 models and more than 3 cars, and select the ids and makers of the car makers.\n\n", "predict": "SELECT car_makers.Id, car_makers.Maker FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model JOIN cars_data ON car_names.MakeId = cars_data.Id GROUP BY car_makers.Id, car_makers.Maker HAVING COUNT(DISTINCT model_list.Model) >= 2 AND COUNT(DISTINCT cars_data.Id) > 3"}, {"db_id": "flight_2", "gold": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"", "question": "Which abbreviation corresponds to Jetblue Airways?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the abbreviation that corresponds to Jetblue Airways.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the abbreviation from the 'airlines' table where the Airline is Jetblue Airways.\n\n<3> SQL Generation: Use 'where' to find the abbreviation from the 'airlines' table where the Airline is Jetblue Airways.\n\n", "predict": "SELECT Abbreviation FROM airlines WHERE Airline = 'Jetblue Airways'"}, {"db_id": "flight_2", "gold": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"", "question": "List the airport code and name in the city of Anthony.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airport code and name in the city of Anthony.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'AirportCode' and 'AirportName' columns from the 'airports' table where the 'City' column is \"Anthony\".\n\n<3> SQL Generation: Use 'where' to filter the rows where the 'City' column is \"Anthony\" and select the 'AirportCode' and 'AirportName' columns.\n\n", "predict": "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\""}, {"db_id": "flight_2", "gold": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"", "question": "Give the airport code and airport name corresonding to the city Anthony.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airport corresponding to the city Anthony. Secondly, we need to retrieve the airport code and airport name for that airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select AirportCode and AirportName from table 'airports' where City = 'Anthony'.\n\n<3> SQL Generation: Use 'where' to find the airport corresponding to the city Anthony, and then select the airport code and airport name.\n\n", "predict": "SELECT AirportCode, AirportName FROM airports WHERE City = 'Anthony'"}, {"db_id": "flight_2", "gold": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"", "question": "Which airline has abbreviation 'UAL'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airline that has the abbreviation 'UAL'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Airline from table 'airlines' where Abbreviation = 'UAL'.\n\n<3> SQL Generation: Use 'where' to filter the airlines based on the abbreviation 'UAL'.\n\n", "predict": "SELECT Airline FROM airlines WHERE Abbreviation = 'UAL'"}, {"db_id": "flight_2", "gold": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"", "question": "Give the airline with abbreviation 'UAL'.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airline with the abbreviation 'UAL'.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step and the foreign key relationships. We will use the 'airlines' table and the 'Abbreviation' column.\n\n<3> SQL Generation: Use 'where' to filter the airline with the abbreviation 'UAL'.\n\n", "predict": "SELECT * FROM airlines WHERE Abbreviation = 'UAL'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"", "question": "How many airlines are from USA?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to count the number of airlines that are from the USA.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'Country' column.\n\n<3> SQL Generation: Use 'where' to filter airlines from the USA and count them.\n\n", "predict": "SELECT count(*) FROM airlines WHERE Country = \"USA\";"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"", "question": "Return the number of airlines in the USA.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter airlines based on their country, specifically the USA.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'Country' column.\n\n<3> SQL Generation: Use 'where' to filter airlines based on their country being the USA, and then count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM airlines WHERE Country = 'USA'"}, {"db_id": "flight_2", "gold": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"", "question": "Give the city and country for the Alton airport.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding the city and country for the Alton airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the city and country from the 'airports' table where the AirportName is 'Alton'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the AirportName is 'Alton', and then select the city and country.\n\n", "predict": "SELECT City, Country FROM airports WHERE AirportName = 'Alton'"}, {"db_id": "flight_2", "gold": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"", "question": "Return the name of the airport with code 'AKO'.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airport with code 'AKO'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table.\n\n<3> SQL Generation: Use 'where' to find the airport with code 'AKO' and select the airport name.\n\n", "predict": "SELECT AirportName FROM airports WHERE AirportCode = 'AKO'"}, {"db_id": "flight_2", "gold": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"", "question": "What are airport names at City 'Aberdeen'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on airports located in the city 'Aberdeen'. We need to select the names of these airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table and the 'AirportName' column.\n\n<3> SQL Generation: Use 'where' to filter airports located in the city 'Aberdeen' and select their names.\n\n", "predict": "SELECT AirportName FROM airports WHERE City = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"", "question": "What are the names of airports in Aberdeen?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airports in Aberdeen. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table and the 'City' column to filter airports in Aberdeen.\n\n<3> SQL Generation: Use 'where' to filter airports in Aberdeen and select their names.\n\n", "predict": "SELECT AirportName FROM airports WHERE City = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"", "question": "How many flights depart from 'APG'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to count the number of flights that depart from the airport with the code 'APG'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flights' table and the 'SourceAirport' column.\n\n<3> SQL Generation: Use 'where' to filter flights that depart from the airport with the code 'APG' and count them.\n\n", "predict": "SELECT count(*) FROM flights WHERE SourceAirport = 'APG';"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"", "question": "Count the number of flights departing from 'APG'.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of flights departing from 'APG'. We need to filter flights based on the source airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from table 'flights' and filter by SourceAirport = 'APG'.\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = 'APG', and then use 'count' to count the number of flights.\n\n", "predict": "SELECT count(*) FROM flights WHERE SourceAirport = 'APG'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"", "question": "How many flights have destination ATO?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter flights based on their destination, specifically ATO.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select count(*) from the table 'flights' where DestAirport is 'ATO'.\n\n<3> SQL Generation: Use 'where' to filter flights with destination ATO and count them.\n\n", "predict": "SELECT count(*) FROM flights WHERE DestAirport = \"ATO\""}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"", "question": "Count the number of flights into ATO.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of flights into ATO. We need to filter out the flights that have ATO as the destination airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the flights from the 'flights' table and filter by the DestAirport column.\n\n<3> SQL Generation: Use 'where' to filter out the flights with ATO as the destination airport and count the number of flights.\n\n", "predict": "SELECT count(*) FROM flights WHERE DestAirport = 'ATO'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "How many flights depart from City Aberdeen?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to count the number of flights that depart from the city Aberdeen.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the FlightNo from the flights table where the SourceAirport is Aberdeen.\n\n<3> SQL Generation: Use 'where' to filter flights that depart from the city Aberdeen and count them.\n\n", "predict": "SELECT count(*) FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = \"Aberdeen\""}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "Return the number of flights departing from Aberdeen.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter flights based on their departure airport, specifically Aberdeen.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of flights from the 'flights' table where the SourceAirport is Aberdeen.\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = Aberdeen, and then use 'count' to get the number of flights.\n\n", "predict": "SELECT COUNT(*) FROM flights WHERE SourceAirport = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "How many flights arriving in Aberdeen city?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of flights arriving in Aberdeen city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of flights from the 'flights' table where the destination airport is in Aberdeen city.\n\n<3> SQL Generation: Use 'where' to filter flights that arrive at airports in Aberdeen city and count them.\n\n", "predict": "SELECT count(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = \"Aberdeen\""}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "Return the number of flights arriving in Aberdeen.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of flights arriving in Aberdeen. We need to filter out the flights that have Aberdeen as the destination airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the flights from the 'flights' table and filter by the destination airport column.\n\n<3> SQL Generation: Use 'where' to filter out the flights arriving in Aberdeen and count the number of flights.\n\n", "predict": "SELECT count(*) FROM flights WHERE DestAirport = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"", "question": "How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the flights that depart from City 'Aberdeen'. Secondly, we need to filter those flights to find the ones with destination City 'Ashley'. Finally, we need to count the number of flights that meet both criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select flights from table 'flights' where SourceAirport matches the AirportCode of City 'Aberdeen'. In the second step, we need to filter the flights from the first step to find the ones with DestAirport matching the AirportCode of City 'Ashley'.\n\n<3> SQL Generation: Use 'where' to filter flights that depart from City 'Aberdeen' and have destination City 'Ashley', and then use 'count' to count the number of flights that meet both criteria.\n\n", "predict": "SELECT count(*) FROM flights AS t1 JOIN airports AS t2 ON t1.SourceAirport = t2.AirportCode JOIN airports AS t3 ON t1.DestAirport = t3.AirportCode WHERE t2.City = 'Aberdeen' AND t3.City = 'Ashley'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"", "question": "How many flights fly from Aberdeen to Ashley?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their source airport and destination airport. Secondly, we need to count the number of flights that meet the filtering criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of flights from table 'flights' and filter by SourceAirport = 'Aberdeen' and DestAirport = 'Ashley'.\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = 'Aberdeen' and DestAirport = 'Ashley', and then use 'count' to calculate the number of flights.\n\n", "predict": "SELECT COUNT(*) FROM flights WHERE SourceAirport = 'Aberdeen' AND DestAirport = 'Ashley'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"", "question": "How many flights does airline 'JetBlue Airways' have?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airline with the name 'JetBlue Airways'. Secondly, we need to count the number of flights associated with that airline.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select uid from table 'airlines' where Airline = 'JetBlue Airways'. In the second step, we need to count the number of flights from table 'flights' where Airline matches the uid found in the first step.\n\n<3> SQL Generation: Use 'where' to find the uid of airline 'JetBlue Airways', and then use 'count' to count the number of flights associated with that uid.\n\n", "predict": "SELECT count(*) FROM flights WHERE Airline = (SELECT uid FROM airlines WHERE Airline = 'JetBlue Airways')"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"", "question": "How many 'United Airlines' flights go to Airport 'ASY'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter flights based on the airline 'United Airlines' and the destination airport 'ASY'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select flights from the 'flights' table where the airline is 'United Airlines' and the destination airport is 'ASY'.\n\n<3> SQL Generation: We can use a simple 'where' clause to filter flights where the airline is 'United Airlines' and the destination airport is 'ASY'. Then, we can count the number of flights that meet this condition.\n\n", "predict": "SELECT count(*) FROM flights WHERE airline = 'United Airlines' AND destAirport = 'ASY'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"", "question": "Count the number of United Airlines flights arriving in ASY Airport.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of United Airlines flights arriving in ASY Airport. We need to filter out the flights that are not operated by United Airlines and the flights that do not arrive at ASY Airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the flights from the 'flights' table and filter by the Airline column for United Airlines. We also need to filter by the DestAirport column for ASY Airport.\n\n<3> SQL Generation: Use 'where' to filter out the flights that are not operated by United Airlines and the flights that do not arrive at ASY Airport, and then use 'count' to count the remaining flights.\n\n", "predict": "SELECT count(*) FROM flights JOIN airlines ON flights.Airline = airlines.Abbreviation WHERE airlines.Airline = 'United Airlines' AND flights.DestAirport = 'ASY'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"", "question": "How many 'United Airlines' flights depart from Airport 'AHD'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the flights that depart from Airport 'AHD'. Secondly, we need to filter the flights that are operated by 'United Airlines' and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select FlightNo from table 'flights' where SourceAirport = 'AHD'. In the second step, we need to filter Airline from table 'flights' where Airline = 'United Airlines'.\n\n<3> SQL Generation: Use 'where' to filter the flights that depart from Airport 'AHD', and then use 'where' to filter the flights that are operated by 'United Airlines' and count them.\n\n", "predict": "SELECT count(*) FROM flights WHERE SourceAirport = 'AHD' AND Airline = 'United Airlines';"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"", "question": "Return the number of United Airlines flights leaving from AHD Airport.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airport with the code \"AHD\" in the table 'airports'. Secondly, we need to filter flights based on their source airport and the airline. Finally, we need to count the number of flights that meet these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select AirportCode from table 'airports' where AirportCode = \"AHD\". In the second step, we need to filter flights based on SourceAirport from table 'flights' and Airline from table 'airlines'.\n\n<3> SQL Generation: Use 'where' to find the airport with the code \"AHD\" in the table 'airports'. Then, use 'where' to filter flights based on their source airport and the airline. Finally, count the number of flights that meet these conditions.\n\n", "predict": "SELECT COUNT(*) FROM flights JOIN airlines ON flights.Airline = airlines.Abbreviation WHERE flights.SourceAirport = \"AHD\" AND airlines.Airline = \"United Airlines\""}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"", "question": "How many United Airlines flights go to City 'Aberdeen'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter flights based on the airline 'United Airlines' and the destination city 'Aberdeen'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select flights from the 'flights' table where the airline is 'United Airlines' and the destination airport is in the city 'Aberdeen'. To find the destination airport, we need to join the 'flights' and 'airports' tables on the 'DestAirport' and 'AirportCode' columns.\n\n<3> SQL Generation: Use 'where' to filter flights with the airline 'United Airlines' and the destination airport in the city 'Aberdeen'. Count the number of flights that meet this condition.\n\n", "predict": "SELECT count(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T1.Airline = 'United Airlines' AND T2.City = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"", "question": "Count the number of United Airlines flights that arrive in Aberdeen.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of United Airlines flights that arrive in Aberdeen. We need to filter out the flights that are operated by United Airlines and arrive at Aberdeen.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the flights from the 'flights' table and filter by the Airline column for United Airlines. We also need to filter by the DestAirport column for Aberdeen.\n\n<3> SQL Generation: Use 'where' to filter out the flights operated by United Airlines and arriving at Aberdeen, and then use 'count' to count the number of such flights.\n\n", "predict": "SELECT count(*) FROM flights WHERE Airline = 'United Airlines' AND DestAirport = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "question": "What is the code of airport that has fewest number of flights?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airport that has the fewest number of flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to count the number of flights for each airport using the 'flights' table and group them by airport code.\n\n<3> SQL Generation: Use 'count' to calculate the number of flights for each airport, and then use 'min' to find the airport with the fewest number of flights.\n\n", "predict": "SELECT SourceAirport, COUNT(*) AS num_flights FROM flights GROUP BY SourceAirport ORDER BY num_flights ASC LIMIT 1"}, {"db_id": "flight_2", "gold": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "question": "Give the code of the airport with the least flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airport with the least number of flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flights' table and the 'airports' table.\n\n<3> SQL Generation: We can use the 'GROUP BY' clause to group the flights by airport code and then use the 'COUNT' function to count the number of flights for each airport. Finally, we can use the 'ORDER BY' clause to sort the airports in ascending order based on the count of flights and select the airport with the least number of flights.\n\n", "predict": "SELECT SourceAirport, COUNT(*) AS num_flights FROM flights GROUP BY SourceAirport ORDER BY num_flights ASC LIMIT 1"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"", "question": "What are airlines that have some flight departing from airport 'AHD'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding airlines that have some flight departing from airport 'AHD'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need tables ['airlines', 'flights', 'airports']. We can join the 'flights' table with the 'airports' table twice, once for the 'SourceAirport' column and once for the 'DestAirport' column. Then, we can join the 'airlines' table with the resulting table on the 'Airline' column.\n\n<3> SQL Generation: We need to use two joins to combine the 'flights' table with the 'airports' table on the 'SourceAirport' and 'DestAirport' columns. Then, we join the resulting table with the 'airlines' table on the 'Airline' column. Finally, we filter the rows where the 'SourceAirport' or 'DestAirport' is 'AHD' and select the distinct 'Airline' column from the 'airlines' table.\n\n", "predict": "SELECT DISTINCT Airline FROM airlines JOIN flights ON airlines.uid = flights.Airline JOIN airports AS source ON flights.SourceAirport = source.AirportCode JOIN airports AS dest ON flights.DestAirport = dest.AirportCode WHERE source.AirportCode = 'AHD' OR dest.AirportCode = 'AHD'"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"", "question": "Which airlines have a flight with source airport AHD?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the flights with source airport AHD. Secondly, we need to retrieve the airlines that operate these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Airline from table 'flights' where SourceAirport = AHD. Then, we need to retrieve the corresponding airlines from table 'airlines'.\n\n<3> SQL Generation: Use 'where' to find the flights with source airport AHD, and then select the corresponding airlines.\n\n", "predict": "SELECT DISTINCT t1.Airline FROM flights AS t1 JOIN airports AS t2 ON t1.SourceAirport = t2.AirportCode WHERE t2.AirportCode = 'AHD'"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"", "question": "What are airlines that have flights arriving at airport 'AHD'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding airlines that have flights arriving at airport 'AHD'. We need to select the names of these airlines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'flights' table with the 'airports' table on the 'DestAirport' column.\n\n<3> SQL Generation: Use 'join' to link the 'flights' table with the 'airports' table on the 'DestAirport' column, and then use 'where' to filter flights arriving at airport 'AHD'. Finally, select the names of the airlines.\n\n", "predict": "SELECT airlines.Airline FROM airlines JOIN flights ON airlines.uid = flights.Airline WHERE flights.DestAirport = 'AHD'"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"", "question": "Which airlines have a flight with destination airport AHD?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the flights with destination airport AHD. Secondly, we need to retrieve the airlines that operate these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Airline from table 'flights' where DestAirport = \"AHD\". Then, we need to retrieve the corresponding airlines from table 'airlines'.\n\n<3> SQL Generation: Use 'where' to find the flights with destination airport AHD, and then select the corresponding airlines.\n\n", "predict": "SELECT DISTINCT Airline FROM flights WHERE DestAirport = \"AHD\""}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "question": "Find all airlines that have at least 10 flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airlines that have at least 10 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flights' table for this query.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter airlines that have at least 10 flights.\n\n", "predict": "SELECT Airline FROM flights GROUP BY Airline HAVING COUNT(*) >= 10"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "question": "Which airlines have at least 10 flights?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airlines that have at least 10 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to count the number of flights for each airline and select the airlines that have at least 10 flights.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of flights for each airline and select the airlines that have at least 10 flights.\n\n", "predict": "SELECT Airline FROM flights GROUP BY Airline HAVING COUNT(*) >= 10"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "question": "Find all airlines that have fewer than 200 flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the airlines that have fewer than 200 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flights' table for this query.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter airlines based on the count of flights being less than 200.\n\n", "predict": "SELECT Airline FROM flights GROUP BY Airline HAVING COUNT(*) < 200"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "question": "Which airlines have less than 200 flights?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to filter airlines based on the number of flights they have, specifically those with less than 200 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'Airline' column.\n\n<3> SQL Generation: Use 'where' to filter airlines with less than 200 flights and select their names.\n\n", "predict": "SELECT Airline FROM airlines WHERE uid IN (SELECT Airline FROM flights GROUP BY Airline HAVING COUNT(*) < 200)"}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"", "question": "What are flight numbers of Airline \"United Airlines\"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the flight numbers of the airline \"United Airlines\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the flight numbers from the 'flights' table where the airline is \"United Airlines\".\n\n<3> SQL Generation: Use 'where' to filter flights with the airline \"United Airlines\", and select the flight numbers.\n\n", "predict": "SELECT FlightNo FROM flights WHERE Airline = \"United Airlines\""}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"", "question": "Which flight numbers correspond to United Airlines flights?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the airline with the name \"United Airlines\". Secondly, we need to find the flight numbers that correspond to this airline.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from table 'flights' where Airline is the uid of the airline named \"United Airlines\".\n\n<3> SQL Generation: Use 'where' to find the uid of the airline named \"United Airlines\", and then use 'where' to filter FlightNo from table 'flights' based on the uid.\n\n", "predict": "SELECT FlightNo FROM flights WHERE Airline = (SELECT uid FROM airlines WHERE Airline = \"United Airlines\")"}, {"db_id": "flight_2", "gold": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"", "question": "What are flight numbers of flights departing from Airport \"APG\"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding flight numbers of flights departing from Airport \"APG\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from the 'flights' table and filter by SourceAirport = \"APG\".\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = \"APG\", and select the FlightNo.\n\n", "predict": "SELECT FlightNo FROM flights WHERE SourceAirport = \"APG\""}, {"db_id": "flight_2", "gold": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"", "question": "Give the flight numbers of flights leaving from APG.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on flights leaving from APG. We need to select the flight numbers of these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from the 'flights' table and filter by SourceAirport = 'APG'.\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = 'APG', and select the flight numbers.\n\n", "predict": "SELECT FlightNo FROM flights WHERE SourceAirport = 'APG'"}, {"db_id": "flight_2", "gold": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"", "question": "What are flight numbers of flights arriving at Airport \"APG\"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on flights that are arriving at Airport \"APG\". We need to select the flight numbers of these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from table 'flights' and filter by DestAirport = \"APG\".\n\n<3> SQL Generation: Use 'where' to filter flights with DestAirport = \"APG\", and then select the FlightNo.\n\n", "predict": "SELECT FlightNo FROM flights WHERE DestAirport = \"APG\""}, {"db_id": "flight_2", "gold": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"", "question": "Give the flight numbers of flights landing at APG.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on flights landing at APG. We need to select the flight numbers of these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from table 'flights' and filter by DestAirport = 'APG'.\n\n<3> SQL Generation: Use 'where' to filter flights with DestAirport = 'APG', and then select the FlightNo.\n\n", "predict": "SELECT FlightNo FROM flights WHERE DestAirport = 'APG'"}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "What are flight numbers of flights departing from City \"Aberdeen \"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding flight numbers of flights departing from the city \"Aberdeen\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from the 'flights' table and filter by SourceAirport from the 'airports' table where City = \"Aberdeen\".\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = \"Aberdeen\", and then select the FlightNo.\n\n", "predict": "SELECT FlightNo FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = \"Aberdeen\""}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "Give the flight numbers of flights leaving from Aberdeen.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: The query requires finding flights that are leaving from Aberdeen. We need to select the flight numbers of these flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the FlightNo from the 'flights' table where the SourceAirport is Aberdeen.\n\n<3> SQL Generation: Use 'where' to filter flights with SourceAirport = Aberdeen, and select the FlightNo.\n\n", "predict": "SELECT FlightNo FROM flights WHERE SourceAirport = 'Aberdeen'"}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "What are flight numbers of flights arriving at City \"Aberdeen\"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find flights that are arriving at the city \"Aberdeen\". \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from the 'flights' table and filter by the destination airport code that corresponds to the city \"Aberdeen\" in the 'airports' table.\n\n<3> SQL Generation: Use 'where' to filter flights with the destination airport code corresponding to the city \"Aberdeen\", and then select the flight numbers.\n\n", "predict": "SELECT FlightNo FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = \"Aberdeen\""}, {"db_id": "flight_2", "gold": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"", "question": "Give the flight numbers of flights arriving in Aberdeen.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "<1> Decomposition: We need to find the flights that are arriving in Aberdeen.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select FlightNo from the 'flights' table where DestAirport is the AirportCode of Aberdeen in the 'airports' table.\n\n<3> SQL Generation: Use 'where' to find the flights that are arriving in Aberdeen, and select the flight numbers.\n\n", "predict": "SELECT FlightNo FROM flights WHERE DestAirport = (SELECT AirportCode FROM airports WHERE City = 'Aberdeen')"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Which cities do more than one employee under age 30 come from?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter employees who are under age 30. Secondly, we need to count the number of employees from each city. Lastly, we need to select the cities where the count is more than one.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'employee' table for this query.\n\n<3> SQL Generation: Use 'where' to filter employees who are under age 30, then use 'group by' and 'having' to count the number of employees from each city, and finally select the cities where the count is more than one.\n\n", "predict": "SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Find the cities that have more than one employee under age 30.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter employees who are under the age of 30. Secondly, we need to count the number of employees in each city. Finally, we need to select the cities that have more than one employee under the age of 30.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Employee_ID and City from the table 'employee' where Age < 30. In the second step, we need to count the number of employees for each city from the table 'employee'. In the final step, we need to select the cities where the count of employees under the age of 30 is more than one.\n\n<3> SQL Generation: Use 'where' to filter employees under the age of 30, then use 'group by' and 'count' to count the number of employees in each city, and finally use 'where' to filter the cities with more than one employee under the age of 30.\n\n", "predict": "SELECT City FROM employee WHERE Age  <  30 GROUP BY City HAVING COUNT(*) > 1"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)", "question": "Find the names of employees who never won any award in the evaluation.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find employees who never won any award in the evaluation. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Employee_ID from the table 'evaluation'. In the second step, we need to select the names from the table 'employee'.\n\n<3> SQL Generation: Use 'not in' to find employees who never won any award in the evaluation, and then select their names from the table 'employee'.\n\n", "predict": "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)", "question": "What are the names of the employees who never received any evaluation?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the names of all employees. Secondly, we need to filter out the employees who have received any evaluation. Finally, we need to return the names of the remaining employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Name from table 'employee' and filter it based on the Employee_ID in table 'evaluation'.\n\n<3> SQL Generation: Use 'where' to filter out the Employee_IDs that appear in the 'evaluation' table, and then select the remaining names.\n\n", "predict": "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)", "question": "Which shops run with no employees? Find the shop names", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the shops that have no employees. Secondly, we need to select the names of those shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find the shops that have no employees, we need the 'shop' and 'hiring' tables. We also need the 'Shop_ID' column from the 'shop' table.\n\n<3> SQL Generation: Use 'where' to find the Shop_ID of the shops that have no employees in the 'hiring' table, and then use 'where' to filter the Shop names from the 'shop' table.\n\n", "predict": "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"", "question": "What is the document name and template id for document with description with the letter 'w' in it?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the document name and template id for the document with a description containing the letter 'w'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document name and template id from the 'Documents' table based on the description.\n\n<3> SQL Generation: Use 'where' to filter the documents with a description containing the letter 'w' and select the document name and template id.\n\n", "predict": "SELECT Documents.Document_Name, Documents.Template_ID FROM Documents WHERE Documents.Document_Description LIKE '%w%'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"", "question": "Return the names and template ids for documents that contain the letter w in their description.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter documents based on their description containing the letter 'w'. Secondly, we need to select the names and template IDs for the filtered documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'Documents' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter documents based on their description containing the letter 'w', and then select the names and template IDs for the filtered documents.\n\n", "predict": "SELECT Document_Name, Template_ID FROM Documents WHERE Document_Description LIKE '%w%'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"", "question": "What is the document id, template id and description for document named \"Robbin CV\"?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the document id, template id, and description for the document named \"Robbin CV\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document id, template id, and description from the 'Documents' table based on the document name. We also need to link the 'Documents' table with the 'Templates' table using the template id.\n\n<3> SQL Generation: Use 'where' to filter the document named \"Robbin CV\" and select the document id, template id, and description.\n\n", "predict": "SELECT Documents.Document_ID, Documents.Template_ID, Documents.Document_Description FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID WHERE Documents.Document_Name = \"Robbin CV\";"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"", "question": "Return the document id, template id, and description for the document with the name Robbin CV.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the document with the name 'Robbin CV'. Secondly, we need to select the document id, template id, and description of the selected document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the document id from the 'Documents' table where the document name is 'Robbin CV'. In the second step, we need to retrieve the template id and description from the 'Documents' table using the document id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to filter documents with the name 'Robbin CV', and then select the document id, template id, and description columns.\n\n", "predict": "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = 'Robbin CV'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "question": "How many documents are using the template with type code 'PPT'?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: We need to find the template with type code 'PPT' and count the number of documents that are using this template.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_ID from the 'Templates' table where Template_Type_Code = 'PPT'. Then, we need to count the number of documents that have this Template_ID in the 'Documents' table.\n\n<3> SQL Generation: Use 'where' to find the template with type code 'PPT', and then use 'where' to filter documents that have this template ID and count them.\n\n", "predict": "SELECT count(*) FROM Documents WHERE Template_ID IN (SELECT Template_ID FROM Templates WHERE Template_Type_Code = 'PPT')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "question": "Count the number of documents that use the PPT template type.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of documents that use the PPT template type. We need to filter out the documents that use the PPT template type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the documents from the 'Documents' table and filter by the Template_Type_Code column.\n\n<3> SQL Generation: Use 'where' to filter out the documents that use the PPT template type and count the remaining documents.\n\n", "predict": "SELECT count(*) FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID WHERE Templates.Template_Type_Code = 'PPT'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "question": "Show ids for all templates that are used by more than one document.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding templates that are used by more than one document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the template IDs from the 'Templates' table and count the number of documents that use each template from the 'Documents' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of documents for each template and filter templates that are used by more than one document.\n\n", "predict": "SELECT Template_ID FROM Documents GROUP BY Template_ID HAVING COUNT(*) > 1"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "question": "What are the template ids of any templates used in more than a single document?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding templates that are used in more than a single document. We need to select the template IDs that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the template IDs from the 'Templates' table and count the occurrences of each template ID in the 'Documents' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the occurrences of each template ID in the 'Documents' table and filter for templates used in more than a single document, and select the template IDs.\n\n", "predict": "SELECT T1.Template_ID FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID GROUP BY T1.Template_ID HAVING COUNT(T2.Document_ID) > 1"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"", "question": "How many templates have template type code CV?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter templates based on their template type code, selecting templates with template type code 'CV'. Secondly, we need to count the number of selected templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter templates based on their template type code, we only need the 'Templates' table.\n\n<3> SQL Generation: Use 'where' to filter templates with template type code 'CV', and then use 'count' to count the number of selected templates.\n\n", "predict": "SELECT count(*) FROM Templates WHERE template_type_code = \"CV\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"", "question": "Count the number of templates of the type CV.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of templates of the type CV. We need to filter out the templates that have the template type CV.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Template_ID from the 'Templates' table and filter by the Template_Type_Code column from the 'Ref_Template_Types' table.\n\n<3> SQL Generation: Use 'where' to filter out the templates of the type CV and count the number of templates.\n\n", "predict": "SELECT count(*) FROM Templates WHERE Template_Type_Code = 'CV'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5", "question": "What is the version number and template type code for the template with version number later than 5?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter templates with version number later than 5. Secondly, we need to retrieve the version number and template type code for those templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select version_number and template_type_code from table 'Templates' and filter by version_number.\n\n<3> SQL Generation: Use 'where' to filter templates with version number later than 5, and then select the version number and template type code.\n\n", "predict": "SELECT version_number, template_type_code FROM templates WHERE version_number > 5"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5", "question": "Return the version numbers and template type codes of templates with a version number greater than 5.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering templates based on their version number being greater than 5. We need to select the version numbers and template type codes of the filtered templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select version_number and template_type_code from the 'Templates' table and filter by version_number.\n\n<3> SQL Generation: Use 'where' to filter templates based on their version number being greater than 5, and then select the version numbers and template type codes of the filtered templates.\n\n", "predict": "SELECT version_number, template_type_code FROM Templates WHERE version_number > 5"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3", "question": "Show all template type codes with less than three templates.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding template type codes with less than three templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Template_Type_Code column from the Ref_Template_Types table and count the number of templates for each template type code from the Templates table.\n\n<3> SQL Generation: Use 'join' to link the Ref_Template_Types and Templates tables based on the Template_Type_Code column. Then, use 'group by' and 'having' to filter template type codes with less than three templates.\n\n", "predict": "SELECT T1.Template_Type_Code FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code GROUP BY T1.Template_Type_Code HAVING COUNT(T2.Template_ID) < 3"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3", "question": "What are the codes of template types that have fewer than 3 templates?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding template types that have fewer than 3 templates. We need to select the codes of these template types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_Type_Code from table 'Ref_Template_Types' and count the number of templates for each template type from table 'Templates'.\n\n<3> SQL Generation: Use 'where' to filter template types that have fewer than 3 templates and select their codes.\n\n", "predict": "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Code IN (SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3)"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"", "question": "What is the template type code of the template used by document with the name \"Data base\"?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: We need to find the template type code of the template used by the document with the name \"Data base\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_Type_Code from table 'Templates' and filter by Document_Name.\n\n<3> SQL Generation: Use 'where' to filter documents with the name \"Data base\", and then select the Template_Type_Code.\n\n", "predict": "SELECT Template_Type_Code FROM documents JOIN templates ON documents.Template_ID = templates.Template_ID WHERE Document_Name = \"Data base\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"", "question": "What are the names of documents that use templates with the code BK?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on documents that use templates with the code BK. We need to identify the template IDs that have the code BK and then retrieve the names of the documents that use those template IDs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_ID from table 'Templates' where Template_Type_Code = 'BK'. Then, we need to retrieve the Document_ID and Document_Name from table 'Documents' where Template_ID matches the selected template IDs.\n\n<3> SQL Generation: Use 'where' to filter templates with the code BK and select their Template_IDs. Then, use 'where' to filter documents based on their Template_IDs and select their Document_Names.\n\n", "predict": "SELECT Document_Name FROM Documents WHERE Template_ID IN (SELECT Template_ID FROM Templates WHERE Template_Type_Code = 'BK')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"", "question": "What is the template type descriptions for template type code \"AD\".", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires retrieving the template type descriptions for template type code \"AD\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_Type_Description from table 'Ref_Template_Types' where Template_Type_Code = \"AD\".\n\n<3> SQL Generation: Use 'where' to filter the template type code and then use 'select' to retrieve the template type descriptions.\n\n", "predict": "SELECT Template_Type_Description FROM Ref_Template_Types WHERE Template_Type_Code = \"AD\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID", "question": "What are the distinct template type descriptions for the templates ever used by any document?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the templates that have been used by any document. Secondly, we need to select the distinct template type descriptions of these templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Template_ID from table 'Documents' to identify the templates that have been used. In the second step, we need to select Template_Type_Description from table 'Ref_Template_Types' to get the distinct template type descriptions.\n\n<3> SQL Generation: Use 'distinct' to select the distinct template type descriptions from table 'Ref_Template_Types' where the Template_Type_Code exists in the Template_Type_Code column of table 'Templates' where the Template_ID exists in the Template_ID column of table 'Documents'.\n\n", "predict": "SELECT DISTINCT Template_Type_Description FROM Ref_Template_Types WHERE Template_Type_Code IN (SELECT Template_Type_Code FROM Templates WHERE Template_ID IN (SELECT Template_ID FROM Documents))"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"", "question": "What are the template ids with template type description \"Presentation\".", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the template type code for the template type description \"Presentation\". Secondly, we need to filter the templates based on the template type code. Finally, we need to return the template ids of the filtered templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select template_id from table 'Templates' and filter it based on the template_type_code in table 'Ref_Template_Types'.\n\n<3> SQL Generation: Use 'where' to filter the templates based on the template type code, and then select the template ids.\n\n", "predict": "SELECT template_id FROM templates WHERE template_type_code IN (SELECT template_type_code FROM ref_template_types WHERE template_type_description = 'Presentation')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"", "question": "Return the ids corresponding to templates with the description 'Presentation'.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the ids corresponding to templates with the description 'Presentation'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Template_ID from the 'Templates' table based on the Template_Type_Description.\n\n<3> SQL Generation: Use 'where' to filter the templates with the description 'Presentation' and select the Template_ID.\n\n", "predict": "SELECT Templates.Template_ID FROM Templates JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Description = 'Presentation';"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "select other_details from paragraphs where paragraph_text like 'korea'", "question": "Show paragraph details for paragraph with text 'Korea ' .", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on the paragraph with text 'Korea'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Paragraph_Text from table 'Paragraphs' and filter by the paragraph with text 'Korea'.\n\n<3> SQL Generation: Use 'where' to filter the paragraph with text 'Korea', and then select the paragraph details.\n\n", "predict": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'", "question": "Show all paragraph ids and texts for the document with name 'Welcome to NY'.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the document with the name 'Welcome to NY' and selecting all paragraph IDs and texts for that document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select paragraph IDs and texts from table 'Paragraphs' where the document name is 'Welcome to NY'.\n\n<3> SQL Generation: Use 'where' to filter documents with the name 'Welcome to NY', and then select all paragraph IDs and texts for that document.\n\n", "predict": "SELECT Paragraph_ID, Paragraph_Text FROM Paragraphs WHERE Document_ID IN (SELECT Document_ID FROM Documents WHERE Document_Name = 'Welcome to NY')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'", "question": "What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the paragraphs in the document titled 'Welcome to NY'. Firstly, we need to find the document with the title 'Welcome to NY'. Secondly, we need to select the ids and texts of the paragraphs in this document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Paragraph_ID and Paragraph_Text from the 'Paragraphs' table and filter by the Document_Name = 'Welcome to NY'.\n\n<3> SQL Generation: Use 'where' to filter documents with the title 'Welcome to NY', and then select the Paragraph_ID and Paragraph_Text.\n\n", "predict": "SELECT Paragraph_ID, Paragraph_Text FROM Paragraphs WHERE Document_ID IN (SELECT Document_ID FROM Documents WHERE Document_Name = 'Welcome to NY')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"", "question": "What are the paragraph texts for the document with the name 'Customer reviews'?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the document_id for the document with the name 'Customer reviews'. Secondly, we need to retrieve the paragraph texts for that document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select document_id from table 'Documents' where document_name = 'Customer reviews'. In the second step, we need to retrieve paragraph_text from table 'Paragraphs' using the document_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the document_id for the document with the name 'Customer reviews', and then use 'select' to retrieve the paragraph texts for that document.\n\n", "predict": "SELECT paragraph_text FROM Paragraphs WHERE document_id  =  (SELECT document_id FROM Documents WHERE document_name  =  'Customer reviews')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2", "question": "List all document ids with at least two paragraphs.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on documents with at least two paragraphs. We need to select the document IDs of these documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Documents' and 'Paragraphs' tables.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter documents with at least two paragraphs, and then select the document IDs of these documents.\n\n", "predict": "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) >= 2"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2", "question": "What are the ids of documents that have 2 or more paragraphs?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on documents with 2 or more paragraphs. We need to select the ids of these documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Documents' and 'Paragraphs' tables.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter documents with 2 or more paragraphs, and select their ids.\n\n", "predict": "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) >= 2"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2", "question": "Give the ids of documents that have between one and two paragraphs.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on documents with a number of paragraphs between one and two. We need to select the ids of these documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Documents' and 'Paragraphs' tables for this query.\n\n<3> SQL Generation: We need to join the 'Documents' and 'Paragraphs' tables on the 'Document_ID' column. Then, we group the rows by 'Document_ID' and count the number of paragraphs for each document. Finally, we filter the rows where the count of paragraphs is between one and two, and select the 'Document_ID' column.\n\n", "predict": "SELECT D.Document_ID FROM Documents AS D JOIN Paragraphs AS P ON D.Document_ID = P.Document_ID GROUP BY D.Document_ID HAVING COUNT(P.Paragraph_ID) BETWEEN 1 AND 2"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'", "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "<1> Decomposition: The query requires finding the document id with paragraph text 'Brazil' and 'Ireland'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document id from the 'Documents' table based on the paragraph text.\n\n<3> SQL Generation: Use 'where' to filter the paragraphs with text 'Brazil' and 'Ireland' and select the document id.\n\n", "predict": "SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID WHERE Paragraphs.Paragraph_Text IN ('Brazil', 'Ireland');"}, {"db_id": "course_teach", "gold": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1", "question": "What is the hometown of the youngest teacher?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "<1> Decomposition: The query requires finding the youngest teacher and retrieving their hometown.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the hometown from the 'teacher' table and filter based on the 'age' column.\n\n<3> SQL Generation: Use 'where' to filter the youngest teacher based on their age and select their hometown.\n\n", "predict": "SELECT Hometown FROM teacher WHERE Age = (SELECT MIN(Age) FROM teacher)"}, {"db_id": "course_teach", "gold": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2", "question": "What are the towns from which at least two teachers come from?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the teachers who come from different towns. Secondly, we need to identify the towns from which at least two teachers come from.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Hometown column from table 'teacher' and count the number of teachers from each town. Then, we need to filter the towns where the count is greater than or equal to 2.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of teachers from each town and filter the towns with a count greater than or equal to 2, and then select the towns.\n\n", "predict": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"}, {"db_id": "course_teach", "gold": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"", "question": "What are the names of the people who teach math courses?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "<1> Decomposition: The query requires finding the people who teach math courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of the people who teach math courses, so we need to join the 'course_arrange' table with the 'teacher' table based on the Teacher_ID column. Then, we need to filter the rows where the Course column is 'math'.\n\n<3> SQL Generation: Use 'join' to combine the 'course_arrange' and 'teacher' tables based on the Teacher_ID column. Then, use 'where' to filter the rows where the Course column is 'math' and select the names of the people.\n\n", "predict": "SELECT Name FROM teacher JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID JOIN course ON course.Course_ID = course_arrange.Course_ID WHERE course.Course = 'math'"}, {"db_id": "museum_visit", "gold": "SELECT count(*) FROM visitor WHERE age  <  30", "question": "How many visitors below age 30 are there?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on visitors below age 30. We need to filter visitors based on their age and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'visitor' table and its 'Age' column.\n\n<3> SQL Generation: Use 'where' to filter visitors below age 30 and count them.\n\n", "predict": "SELECT count(*) FROM visitor WHERE Age < 30"}, {"db_id": "museum_visit", "gold": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC", "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter visitors whose membership level is higher than 4. Secondly, we need to retrieve their names. Lastly, we need to order the results by the level from high to low.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Name from table 'visitor' and filter by Level_of_membership.\n\n<3> SQL Generation: Use 'where' to filter visitors whose membership level is higher than 4. Then, select their names and order the results by the level from high to low.\n\n", "predict": "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC"}, {"db_id": "museum_visit", "gold": "SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4", "question": "What is the average age of the visitors whose membership level is not higher than 4?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on visitors whose membership level is not higher than 4. Firstly, we need to identify the visitors with a membership level not higher than 4. Secondly, we need to calculate the average age of these visitors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the membership level is in the 'visitor' table and the age is also in the 'visitor' table, we only need to use the 'visitor' table.\n\n<3> SQL Generation: Use 'where' to filter visitors with a membership level not higher than 4, and then calculate the average age of these visitors.\n\n", "predict": "SELECT AVG(Age) FROM visitor WHERE Level_of_membership <= 4"}, {"db_id": "museum_visit", "gold": "SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'", "question": "What are the opening year and staff number of the museum named Plaza Museum?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: We need to find the opening year and staff number of the museum named \"Plaza Museum\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'museum' table.\n\n<3> SQL Generation: We can use a 'where' clause to filter the rows where the museum name is \"Plaza Museum\", and then select the opening year and staff number from the 'museum' table.\n\n", "predict": "SELECT open_year, num_of_staff FROM museum WHERE name = 'Plaza Museum'"}, {"db_id": "museum_visit", "gold": "SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)", "question": "find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the minimum staff number of all museums opened after 2010. Secondly, we need to filter museums based on their staff number being higher than the minimum staff number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the minimum staff number from the 'museum' table where the open year is after 2010. Then, we need to select the names of museums from the 'museum' table where the number of staff is higher than the minimum staff number.\n\n<3> SQL Generation: Use 'min' to calculate the minimum staff number of all museums opened after 2010, and then use 'where' to filter museums with a staff number higher than the minimum staff number. Finally, select the names of the filtered museums.\n\n", "predict": "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT min(Num_of_Staff) FROM museum WHERE Open_Year > 2010)"}, {"db_id": "museum_visit", "gold": "SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1", "question": "find the id, name and age for visitors who visited some museums more than once.", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: We need to filter visitors who visited some museums more than once. Then, we need to retrieve their ID, name, and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select ID, Name, and Age from table 'visitor' and filter by the number of visits to museums.\n\n<3> SQL Generation: Use 'where' to filter visitors who visited some museums more than once, and then select their ID, name, and age.\n\n", "predict": "SELECT ID, Name, Age FROM visitor WHERE ID IN (SELECT visitor_ID FROM visit GROUP BY visitor_ID HAVING COUNT(Museum_ID) > 1)"}, {"db_id": "museum_visit", "gold": "SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)", "question": "What is the name of the museum that had no visitor yet?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: We need to find the museum that had no visitor yet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'museum' table for this query.\n\n<3> SQL Generation: Use 'where' to filter museums that had no visitors yet and select the name of the museum.\n\n", "predict": "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"}, {"db_id": "museum_visit", "gold": "SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1", "question": "What is the total ticket expense of the visitors whose membership level is 1?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the membership level column in the visitor table. We need to select the total ticket expense of the visitors with a membership level of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the visit table to retrieve the total ticket expense and the visitor table to filter on the membership level.\n\n<3> SQL Generation: Use the 'where' clause to filter the visitors with a membership level of 1 and then calculate the sum of their total ticket expenses.\n\n", "predict": "SELECT SUM(T1.Total_spent) FROM visit AS T1 JOIN visitor AS T2 ON T1.visitor_ID = T2.ID WHERE T2.Level_of_membership = 1"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'", "question": "List the first name and birth date of all players from the country with code USA.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the country with code 'USA'. Secondly, we need to select the first name and birth date of all players from that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first_name and birth_date from table 'players' and filter based on country_code from table 'players'.\n\n<3> SQL Generation: Use 'where' to filter players based on the country code 'USA', and then select the first name and birth date of the filtered players.\n\n", "predict": "SELECT first_name, birth_date FROM players WHERE country_code = 'USA'"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'", "question": "What are the first names and birth dates of players from the USA?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter players based on their country code. Secondly, we need to select the first names and birth dates of the filtered players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first names and birth dates from the 'players' table and filter by country code = 'USA'.\n\n<3> SQL Generation: Use 'where' to filter players with country code = 'USA', and then select the first names and birth dates.\n\n", "predict": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  \"USA\""}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT country_code) FROM players", "question": "find the number of distinct country codes of all players.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: The query requires finding the distinct country codes of all players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the country_code column from the players table.\n\n<3> SQL Generation: We can use the DISTINCT keyword to select only the unique country codes from the players table. Then, we can count the number of distinct country codes.\n\n", "predict": "SELECT COUNT(DISTINCT country_code) FROM players"}, {"db_id": "wta_1", "gold": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10", "question": "Find the name of tourney that has more than 10 matches.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: We need to filter tournaments based on the number of matches they have, specifically those with more than 10 matches. Then, we need to retrieve the name of these tournaments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the tourney_name from the 'matches' table and count the number of matches for each tournament.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter tournaments with more than 10 matches, and then select their tourney_name.\n\n", "predict": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*) > 10"}, {"db_id": "wta_1", "gold": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10", "question": "What are the names of tournaments that have more than 10 matches?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on tournaments with more than 10 matches. We need to select the names of these tournaments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'matches' table for this query.\n\n<3> SQL Generation: Use 'where' to filter matches and count the number of matches for each tournament. Then, select the tournament names where the count is greater than 10.\n\n", "predict": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1", "question": "Find the first name and country code of the oldest player.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the oldest player. Secondly, we need to select the first name and country code of the oldest player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select birth_date, first_name, and country_code from the 'players' table.\n\n<3> SQL Generation: Use 'select min(birth_date)' to find the oldest player's birth date. Then, use 'where' to filter the player with the oldest birth date and select their first name and country code.\n\n", "predict": "SELECT first_name, country_code FROM players WHERE birth_date = (SELECT min(birth_date) FROM players)"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1", "question": "What is the first name and country code of the oldest player?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: We need to find the oldest player based on their birth date. Then, we need to retrieve their first name and country code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the player_id, first_name, and country_code from the players table. We also need to filter the players based on their birth date to find the oldest player.\n\n<3> SQL Generation: Use 'order by' and 'limit' to find the player with the oldest birth date. Then, use 'select' to retrieve their first name and country code.\n\n", "predict": "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "question": "What are the full names of all left handed players, in order of birth date?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: The query requires finding left-handed players and retrieving their full names. Additionally, the players should be ordered by their birth date.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name and last name from the 'players' table and filter out the players who are not left-handed.\n\n<3> SQL Generation: We can use a join between the 'players' and 'rankings' tables on the 'player_id' column to get the left-handed players. Then, we can order the result by the 'birth_date' column and select the full names of these players.\n\n", "predict": "SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM players WHERE hand = 'L' ORDER BY birth_date"}, {"db_id": "wta_1", "gold": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "question": "Find the name and rank points of the winner who won the most times.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: We need to find the winner who won the most times. Then, we need to retrieve their name and rank points.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select winner_id from table 'matches' and count the number of times each winner_id appears. Then, we need to select the winner's name and rank points from table 'players' and 'rankings' based on the winner_id.\n\n<3> SQL Generation: Use 'group by' and 'order by' to count the number of times each winner_id appears and select the winner with the highest count. Then, retrieve the winner's name and rank points.\n\n", "predict": "SELECT p.first_name, p.last_name, r.ranking_points\nFROM players AS p\nJOIN matches AS m ON p.player_id = m.winner_id\nJOIN rankings AS r ON p.player_id = r.player_id\nGROUP BY m.winner_id\nORDER BY COUNT(*) DESC\nLIMIT 1"}, {"db_id": "wta_1", "gold": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50", "question": "Find the codes of countries that have more than 50 players.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: We need to filter countries based on the number of players they have, specifically those with more than 50 players. Then, we need to retrieve their country codes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select country_code from table 'players' and filter by the number of players.\n\n<3> SQL Generation: Use 'where' to filter countries with more than 50 players, and then select their country codes.\n\n", "predict": "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"}, {"db_id": "wta_1", "gold": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50", "question": "What are the codes of countries with more than 50 players?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries with more than 50 players. Firstly, we need to identify the countries that have more than 50 players. Secondly, we need to retrieve their country codes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the number of players in each country, we need to use the 'players' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter countries with more than 50 players, and select their country codes.\n\n", "predict": "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "question": "Find the number of left handed winners who participated in the WTA Championships.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "<1> Decomposition: We need to find the left-handed winners who participated in the WTA Championships.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the player_id from the 'players' table where the hand is 'L' (indicating left-handed players). Then, we need to find the winners who have participated in the WTA Championships from the 'matches' table based on the player_id. \n\n<3> SQL Generation: Use 'where' to find the player_id of left-handed players. Then, use 'where' to filter the winners who have participated in the WTA Championships based on the player_id.\n\n", "predict": "SELECT COUNT(DISTINCT winner_id) FROM matches WHERE winner_id IN (SELECT player_id FROM players WHERE hand = 'L') AND tourney_name = 'WTA Championships'"}, {"db_id": "battle_death", "gold": "SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'", "question": "How many ships ended up being 'Captured'?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of ships that ended up being 'Captured'. We need to filter ships based on their disposition, specifically 'Captured'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the id from the 'battle' table and filter based on the ships' disposition mentioned in the 'ship' table.\n\n<3> SQL Generation: Use 'where' to filter ships based on their disposition and count the number of ships.\n\n", "predict": "SELECT count(*) FROM ship WHERE disposition_of_ship = \"Captured\""}, {"db_id": "battle_death", "gold": "SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'", "question": "What are the death and injury situations caused by the ship with tonnage 't'?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the ship with tonnage 't'. Secondly, we need to find the battles in which this ship was lost. Finally, we need to find the death and injury situations caused by this ship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'ship' table with the 'battle' table on the 'lost_in_battle' column to find the battles in which the ship was lost. Then, we can join the 'death' table with the 'ship' table on the 'caused_by_ship_id' column to find the death and injury situations caused by the ship.\n\n<3> SQL Generation: Use 'join' to link the 'ship' and 'battle' tables on the 'lost_in_battle' column. Then, use 'join' to link the 'death' and 'ship' tables on the 'caused_by_ship_id' column. Finally, use 'where' to filter the rows where the tonnage of the ship is 't' and select the death and injury situations from the 'death' table.\n\n", "predict": "SELECT death ,  injured FROM death JOIN ship ON death.caused_by_ship_id  =  ship.id WHERE ship.tonnage  =  't'"}, {"db_id": "battle_death", "gold": "SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'", "question": "What are the name and results of the battles when the bulgarian commander is not 'Boril'", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the bulgarian_commander column in the battle table. We need to select the name and result of the battles where the bulgarian commander is not 'Boril'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the battle table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the battles where the bulgarian commander is not 'Boril' and select the name and result of those battles.\n\n", "predict": "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril'"}, {"db_id": "battle_death", "gold": "SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10", "question": "What are the ids and names of the battles that led to more than 10 people killed in total.", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on battles that led to more than 10 people killed in total. Firstly, we need to identify the battles where more than 10 people were killed. Secondly, we need to retrieve their ids and names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'killed' column in the 'death' table, we need to join the 'battle' and 'death' tables.\n\n<3> SQL Generation: Use 'join' to link the 'battle' and 'death' tables based on the foreign key relationship. Then, use 'group by' to group the battles by their ids and names, and use 'having' to filter the battles where the total number of people killed is more than 10. Finally, select the ids and names of the filtered battles.\n\n", "predict": "SELECT battle.id, battle.name FROM battle JOIN death ON battle.id = death.caused_by_ship_id GROUP BY battle.id, battle.name HAVING SUM(death.killed) > 10"}, {"db_id": "battle_death", "gold": "SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'", "question": "What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter battles based on the commanders involved, selecting battles between 'Kaloyan' and 'Baldwin I'. Secondly, we need to retrieve the distinct names of the selected battles.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'battle' table and its 'name' column.\n\n<3> SQL Generation: Use 'where' to filter battles based on the commanders involved, and then select the distinct names of the selected battles.\n\n", "predict": "SELECT DISTINCT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"}, {"db_id": "battle_death", "gold": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'", "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: The query requires finding the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name and date from the 'battle' table and the name from the 'ship' table.\n\n<3> SQL Generation: We need to join the 'battle' and 'ship' tables on the corresponding foreign keys. Then, we filter the rows where the ship name is either 'Lettice' or 'HMS Atalanta'. Finally, we select the name and date of the battle.\n\n", "predict": "SELECT b.name, b.date FROM battle AS b JOIN ship AS s ON b.id = s.lost_in_battle WHERE s.name = 'Lettice' OR s.name = 'HMS Atalanta'"}, {"db_id": "battle_death", "gold": "SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'", "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter battles that have no ships lost in the 'English Channel'. Secondly, we need to select the names, results, and Bulgarian commanders of those battles.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'battle' where location = 'English Channel'. In the second step, we need to select name, result, and bulgarian_commander from table 'battle'.\n\n<3> SQL Generation: Use 'where' to filter battles with no ships lost in the 'English Channel', and then select the names, results, and Bulgarian commanders.\n\n", "predict": "SELECT name, result, bulgarian_commander FROM battle WHERE id NOT IN (SELECT lost_in_battle FROM ship WHERE location = 'English Channel')"}, {"db_id": "battle_death", "gold": "SELECT note FROM death WHERE note LIKE '%East%'", "question": "What are the notes of the death events which has substring 'East'?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the death events that have a substring 'East' in their notes. Secondly, we need to retrieve the notes of those death events.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select id from table 'death' where the note column contains the substring 'East'.\n\n<3> SQL Generation: Use 'where' and 'like' to filter the death events with notes containing the substring 'East', and then select the notes of those death events.\n\n", "predict": "SELECT note FROM death WHERE note LIKE '%East%'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'", "question": "What is the zip code of the address in the city Port Chelsea?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding the zip code of the address in the city Port Chelsea.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the zip_postcode from the 'Addresses' table where the city is 'Port Chelsea'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the city is 'Port Chelsea', and then select the zip_postcode.\n\n", "predict": "SELECT zip_postcode FROM Addresses WHERE city = \"Port Chelsea\";"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'", "question": "What is the zip code for Port Chelsea?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the address_id for Port Chelsea. Secondly, we need to retrieve the zip code for that address.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select address_id from table 'Addresses' where city = 'Port Chelsea'. In the second step, we need to retrieve zip_postcode from table 'Addresses' using the address_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the address_id for Port Chelsea, and then use 'select' to retrieve the zip code for that address.\n\n", "predict": "SELECT zip_postcode FROM Addresses WHERE city = \"Port Chelsea\""}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "question": "What are the names and id of courses having at most 2 sections?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on courses with at most 2 sections. We need to select the names and ids of these courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Courses' and 'Sections' tables.\n\n<3> SQL Generation: Use 'join' to link the 'Courses' and 'Sections' tables on the 'course_id' column. Then, use 'group by' and 'having' to filter courses with at most 2 sections. Finally, select the names and ids of these courses.\n\n", "predict": "SELECT Courses.course_id, Courses.course_name FROM Courses JOIN Sections ON Courses.course_id = Sections.course_id GROUP BY Courses.course_id, Courses.course_name HAVING COUNT(Sections.section_id) <= 2;"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "question": "What are the names and ids of every course with less than 2 sections?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the courses with less than 2 sections. Secondly, we need to retrieve their names and ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Courses' and 'Sections' tables.\n\n<3> SQL Generation: Use 'count' to calculate the number of sections for each course, and then use 'where' to filter courses with less than 2 sections and select their names and ids.\n\n", "predict": "SELECT course_id, course_name FROM Courses WHERE course_id IN (SELECT course_id FROM Sections GROUP BY course_id HAVING COUNT(*) < 2)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'", "question": "What is the description of the department whose name has the substring the computer?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the department with the name containing the substring \"computer\". Secondly, we need to retrieve the description of this department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select department_id from table 'Departments' where department_name contains the substring \"computer\". In the second step, we need to select department_description from table 'Departments' where department_id matches the department_id of the selected department.\n\n<3> SQL Generation: Use 'where' to find the department with the name containing the substring \"computer\", and then use 'where' to retrieve its description.\n\n", "predict": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'", "question": "What is the department description for the one whose name has the word computer?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the department_id for the department whose name contains the word \"computer\". Secondly, we need to retrieve the department_description for that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select department_id from table 'Departments' where department_name contains the word \"computer\". In the second step, we need to retrieve department_description from table 'Departments' using the department_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the department_id for the department whose name contains the word \"computer\", and then use 'select' to retrieve the department_description for that department.\n\n", "predict": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who are enrolled in 2 degree programs in one semester. Secondly, we need to list their first name, middle name, last name, and id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the student_id from the table 'Student_Enrolment' where the count of distinct degree_program_id is equal to 2 and the count of distinct semester_id is equal to 1. In the second step, we need to select the first name, middle name, last name, and id from the table 'Students' where the student_id matches the one found in the first step.\n\n<3> SQL Generation: Use 'where' to find the student_id of students who are enrolled in 2 degree programs in one semester, and then use 'where' to find their first name, middle name, last name, and id.\n\n", "predict": "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id WHERE (SELECT COUNT(DISTINCT T3.degree_program_id) FROM Student_Enrolment AS T3 WHERE T3.student_id = T1.student_id AND T3.semester_id = T2.semester_id) = 2 AND (SELECT COUNT(DISTINCT T4.semester_id) FROM Student_Enrolment AS T4 WHERE T4.student_id = T1.student_id) = 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding students who enrolled in 2 degree programs in one semester and retrieving their first, middle, and last names, along with their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first, middle, and last names, along with the ids, from the 'Students' table and filter by students who enrolled in 2 degree programs in one semester from the 'Student_Enrolment' table.\n\n<3> SQL Generation: We can join the 'Students', 'Student_Enrolment', and 'Degree_Programs' tables on the 'student_id' column and filter by students who enrolled in 2 degree programs in one semester. Finally, we can select the first, middle, and last names, along with the ids, of these students.\n\n", "predict": "SELECT student_id, first_name, middle_name, last_name FROM Students WHERE student_id IN (SELECT student_id FROM Student_Enrolment GROUP BY student_id, semester_id HAVING COUNT(DISTINCT degree_program_id) = 2)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter students who are enrolled in a Bachelors program. Secondly, we need to select the first, middle, and last names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first, middle, and last names from the 'Students' table and filter by the degree program from the 'Degree_Programs' table.\n\n<3> SQL Generation: Join the 'Students' and 'Student_Enrolment' tables on the 'student_id' column. Then, join the 'Student_Enrolment' and 'Degree_Programs' tables on the 'degree_program_id' column and filter by the degree program. Finally, select the first, middle, and last names of the students.\n\n", "predict": "SELECT first_name ,  middle_name ,  last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T2.student_id  =  T1.student_id JOIN Degree_Programs AS T3 ON T3.degree_program_id  =  T2.degree_program_id WHERE T3.degree_summary_name  =  \"Bachelors\""}, {"db_id": "student_transcripts_tracking", "gold": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )", "question": "Which semesters do not have any student enrolled? List the semester name.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the semesters that do not have any student enrolled. Secondly, we need to retrieve the names of those semesters.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select semester_id from table 'Student_Enrolment' and filter the semesters that do not have any student enrolled. Then, we need to retrieve the semester_id and semester_name from table 'Semesters'.\n\n<3> SQL Generation: Use 'where' to filter the semesters that do not have any student enrolled, and then select the semester_name from table 'Semesters'.\n\n", "predict": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT semester_id FROM Student_Enrolment)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )", "question": "What is the name of the semester with no students enrolled?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: We need to find the semester with no students enrolled.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the semester_name from the Semesters table.\n\n<3> SQL Generation: We can use the NOT EXISTS clause to check if there are no records in the Student_Enrolment table for a particular semester, and then select the semester_name of the semester with no students enrolled.\n\n", "predict": "SELECT semester_name FROM Semesters WHERE NOT EXISTS (SELECT * FROM Student_Enrolment WHERE Student_Enrolment.semester_id = Semesters.semester_id)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id", "question": "What are the names of all courses that have some students enrolled?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding courses that have some students enrolled and retrieving their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select course names from the 'Courses' table and filter out the courses that do not have any entries in the 'Student_Enrolment_Courses' table.\n\n<3> SQL Generation: We can use an inner join between the 'Courses' and 'Student_Enrolment_Courses' tables on the 'course_id' column. Then, we can select the course names.\n\n", "predict": "SELECT course_name FROM Courses WHERE course_id IN (SELECT course_id FROM Student_Enrolment_Courses)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2", "question": "Show the date and id of the transcript with at least 2 course results.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: We need to filter transcripts with at least 2 course results. We need to select the date and id of these transcripts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the date and id from table 'Transcripts' and filter by the number of course results from table 'Transcript_Contents'.\n\n<3> SQL Generation: Use 'where' to filter transcripts with at least 2 course results, and then select the date and id.\n\n", "predict": "SELECT transcript_date, transcript_id FROM Transcripts WHERE transcript_id IN (SELECT transcript_id FROM Transcript_Contents GROUP BY transcript_id HAVING COUNT(*) >= 2)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2", "question": "What is the date and id of the transcript with at least 2 courses listed?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: We need to find the transcript with at least 2 courses listed. We need to retrieve the date and id of this transcript.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to count the number of courses listed for each transcript in the 'Student_Enrolment_Courses' table. In the second step, we need to filter the transcripts with at least 2 courses listed and retrieve their date and id from the 'Transcripts' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of courses listed for each transcript, and then use 'where' to filter the transcripts with at least 2 courses listed and select their date and id.\n\n", "predict": "SELECT T1.transcript_date ,  T1.transcript_id FROM Transcripts AS T1 JOIN Transcript_Contents AS T2 ON T1.transcript_id  =  T2.transcript_id JOIN Student_Enrolment_Courses AS T3 ON T3.student_course_id  =  T2.student_course_id GROUP BY T1.transcript_id HAVING COUNT(T3.course_id) >= 2"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'", "question": "What is the phone number of the man with the first name Timmothy and the last name Ward?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the student with the first name 'Timmothy' and last name 'Ward'. Secondly, we need to retrieve the phone number of the selected student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the phone number of the student, we only need the 'Students' table.\n\n<3> SQL Generation: Use 'where' to filter students with the first name 'Timmothy' and last name 'Ward', and then select the phone number column.\n\n", "predict": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward'"}, {"db_id": "student_transcripts_tracking", "gold": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Timmothy Ward'. Secondly, we need to retrieve their mobile phone number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select cell_mobile_number from table 'Students' where first_name = 'Timmothy' and last_name = 'Ward'.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'Timmothy Ward', and then select their mobile phone number.\n\n", "predict": "SELECT cell_mobile_number FROM Students WHERE first_name = \"Timmothy\" AND last_name = \"Ward\";"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1", "question": "What is the first, middle, and last name of the earliest school graduate?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the earliest school graduate in the table 'Transcripts'. Secondly, we need to retrieve the first, middle, and last name of that graduate from the table 'Students'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the transcript_id with the earliest transcript_date from the table 'Transcripts'. In the second step, we need to retrieve the student_id from the table 'Transcript_Contents' where the transcript_id matches the transcript_id found in the first step. Finally, we need to retrieve the first, middle, and last name from the table 'Students' where the student_id matches the student_id found in the second step.\n\n<3> SQL Generation: Use 'where' to find the transcript_id with the earliest transcript_date in the table 'Transcripts'. Then, use 'where' to find the student_id from the table 'Transcript_Contents' where the transcript_id matches the transcript_id found in the first step. Finally, use 'where' to retrieve the first, middle, and last name from the table 'Students' where the student_id matches the student_id found in the second step.\n\n", "predict": "SELECT T2.first_name, T2.middle_name, T2.last_name FROM Transcripts AS T1 JOIN Transcript_Contents AS T3 ON T1.transcript_id = T3.transcript_id JOIN Student_Enrolment_Courses AS T4 ON T3.student_course_id = T4.student_course_id JOIN Student_Enrolment AS T5 ON T4.student_enrolment_id = T5.student_enrolment_id JOIN Students AS T2 ON T5.student_id = T2.student_id WHERE T1.transcript_date = (SELECT min(transcript_date) FROM Transcripts)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1", "question": "Show the date of the transcript which shows the least number of results, also list the id.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding the transcript with the least number of results. Firstly, we need to count the number of results for each transcript. Secondly, we need to identify the transcript with the minimum count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to count the number of results for each transcript by joining the necessary tables. In the second step, we need to select the transcript with the minimum count and retrieve its date and id.\n\n<3> SQL Generation: We can use a combination of joins, grouping, and subqueries to achieve the desired result. First, we join the necessary tables to get the count of results for each transcript. Then, we use a subquery to find the minimum count. Finally, we join the necessary tables again to retrieve the date and id of the transcript with the minimum count.\n\n", "predict": "SELECT T2.transcript_date, T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id GROUP BY T1.transcript_id HAVING COUNT(*) = (SELECT MIN(result_count) FROM (SELECT COUNT(*) AS result_count FROM Transcript_Contents GROUP BY transcript_id) AS T3)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT current_address_id) FROM Students", "question": "What are the different addresses that have students living there?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "<1> Decomposition: We need to find the different addresses where students are living.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the addresses from the 'Addresses' table where the address_id matches the current_address_id or permanent_address_id in the 'Students' table.\n\n<3> SQL Generation: Use 'where' to filter the addresses from the 'Addresses' table where the address_id matches the current_address_id or permanent_address_id in the 'Students' table.\n\n", "predict": "SELECT DISTINCT line_1, line_2, line_3, city, zip_postcode, state_province_county, country, other_address_details FROM Addresses WHERE address_id IN (SELECT current_address_id FROM Students UNION SELECT permanent_address_id FROM Students)"}, {"db_id": "tvshow", "gold": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";", "question": "List all cartoon directed by \"Ben Jones\".", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to filter cartoons based on the director \"Ben Jones\". \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select cartoons from the table 'Cartoon' and filter based on the director from the table 'TV_Channel'.\n\n<3> SQL Generation: Use 'where' to filter cartoons based on the director \"Ben Jones\".\n\n", "predict": "SELECT * FROM Cartoon WHERE Directed_by = \"Ben Jones\""}, {"db_id": "tvshow", "gold": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";", "question": "What are the names of all cartoons directed by Ben Jones?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoons directed by Ben Jones. Secondly, we need to select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Title' column from the 'Cartoon' table and filter by 'Directed_by' column.\n\n<3> SQL Generation: Use 'where' to filter cartoons directed by Ben Jones, and then select their names.\n\n", "predict": "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones'"}, {"db_id": "tvshow", "gold": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";", "question": "How many cartoons were written by \"Joseph Kuhr\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoons written by \"Joseph Kuhr\". Secondly, we need to count the number of cartoons found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for cartoons written by \"Joseph Kuhr\", we need to select the cartoons from the 'Cartoon' table where the 'Written_by' column is 'Joseph Kuhr'.\n\n<3> SQL Generation: Use 'where' to filter the cartoons written by \"Joseph Kuhr\", and then use 'count' to count the number of cartoons.\n\n", "predict": "SELECT count(*) FROM cartoon WHERE written_by = 'Joseph Kuhr'"}, {"db_id": "tvshow", "gold": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";", "question": "What is the number of cartoones written by Joseph Kuhr?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the number of cartoons written by Joseph Kuhr.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select cartoons from the 'Cartoon' table where the 'Written_by' column matches \"Joseph Kuhr\".\n\n<3> SQL Generation: Use 'where' to filter cartoons based on the 'Written_by' column and count the number of cartoons that meet the condition.\n\n", "predict": "SELECT COUNT(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\""}, {"db_id": "tvshow", "gold": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";", "question": "What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on cartoons directed by Ben Jones or Brandon Vietti. We need to select the titles of these cartoons.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Cartoon' table and the 'Title' and 'Directed_by' columns.\n\n<3> SQL Generation: We need to filter the rows where the 'Directed_by' column is either Ben Jones or Brandon Vietti. Finally, we select the 'Title' column from the 'Cartoon' table.\n\n", "predict": "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'"}, {"db_id": "tvshow", "gold": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";", "question": "What is the content of TV Channel with serial name \"Sky Radio\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to find the content of the TV Channel with the serial name \"Sky Radio\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Content column from the TV_Channel table.\n\n<3> SQL Generation: We can use the WHERE clause to filter the TV_Channel table based on the serial name \"Sky Radio\" and then select the Content column.\n\n", "predict": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\""}, {"db_id": "tvshow", "gold": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";", "question": "What is the Package Option of TV Channel with serial name \"Sky Radio\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to find the Package Option of the TV Channel with the serial name \"Sky Radio\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Package_Option from the TV_Channel table where the series_name is \"Sky Radio\".\n\n<3> SQL Generation: We can use the SELECT statement to select the Package_Option from the TV_Channel table where the series_name is \"Sky Radio\".\n\n", "predict": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\""}, {"db_id": "tvshow", "gold": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";", "question": "What are the Package Options of the TV Channels whose series names are Sky Radio?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on TV Channels whose series names are \"Sky Radio\". We need to select the Package Options of these TV Channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Package Options from the 'TV_Channel' table and filter based on the 'series_name' column. We also need to join the 'TV_series' table with the 'TV_Channel' table using the 'Channel' column.\n\n<3> SQL Generation: Use 'where' to filter TV Channels whose series names are \"Sky Radio\" and select their Package Options.\n\n", "predict": "SELECT T1.Package_Option FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.series_name = \"Sky Radio\""}, {"db_id": "tvshow", "gold": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";", "question": "How many TV Channel using language English?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires counting the number of TV channels that use the English language. We need to filter TV channels based on the language mentioned in the 'TV_Channel' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the id from the 'TV_Channel' table and filter based on the language mentioned in the 'TV_Channel' table.\n\n<3> SQL Generation: Use 'where' to filter TV channels based on the language mentioned in the 'TV_Channel' table and count the number of TV channels.\n\n", "predict": "SELECT count(*) FROM TV_Channel WHERE Language = \"English\""}, {"db_id": "tvshow", "gold": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";", "question": "How many TV Channels use the English language?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the TV channels that use the English language. Secondly, we need to count the number of TV channels that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the TV channels from table 'TV_Channel' where Language = 'English'.\n\n<3> SQL Generation: Use 'where' to filter TV channels that use the English language, and then use 'count' to count the number of TV channels.\n\n", "predict": "SELECT count(*) FROM tv_channel WHERE language = \"English\""}, {"db_id": "tvshow", "gold": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";", "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\" and listing the TV Channel's series name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the TV Channel's series name from the 'TV_Channel' table where the cartoon title matches.\n\n<3> SQL Generation: Use 'where' to filter the cartoon with the title \"The Rise of the Blue Beetle!\" and join the 'TV_Channel' table to get the TV Channel's series name.\n\n", "predict": "SELECT TV_Channel.series_name FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Title = \"The Rise of the Blue Beetle!\""}, {"db_id": "tvshow", "gold": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";", "question": "What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoon with the title \"The Rise of the Blue Beetle\". Secondly, we need to find the TV Channel that shows this cartoon. Finally, we need to retrieve the series name of that TV Channel.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the cartoon with the title \"The Rise of the Blue Beetle\" from the 'Cartoon' table. In the second step, we need to find the TV Channel that shows this cartoon by matching the 'Channel' column in the 'Cartoon' table with the 'id' column in the 'TV_Channel' table. In the final step, we need to retrieve the series name from the 'TV_Channel' table for the TV Channel found in the second step.\n\n<3> SQL Generation: Use 'where' to find the cartoon with the title \"The Rise of the Blue Beetle\" in the 'Cartoon' table, then use 'where' to find the TV Channel that shows this cartoon in the 'TV_Channel' table, and finally use 'where' to retrieve the series name of that TV Channel.\n\n", "predict": "SELECT series_name FROM TV_Channel WHERE id = (SELECT Channel FROM Cartoon WHERE Title = \"The Rise of the Blue Beetle\")"}, {"db_id": "tvshow", "gold": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";", "question": "List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to find the TV Channel with series name \"Sky Radio\" and then find the title of all Cartoons showed on that TV Channel.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'id' from the 'TV_Channel' table where series_name = \"Sky Radio\". Then, we need to select the 'Title' from the 'Cartoon' table where Channel = the 'id' found in the previous step.\n\n<3> SQL Generation: We can use 'where' to find the 'id' of the TV Channel with series name \"Sky Radio\". Then, we can use 'where' to find the title of all Cartoons showed on that TV Channel.\n\n", "predict": "SELECT Title FROM Cartoon WHERE Channel IN (SELECT id FROM TV_Channel WHERE series_name = \"Sky Radio\")"}, {"db_id": "tvshow", "gold": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";", "question": "What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the TV Channel with the series name \"Sky Radio\". Secondly, we need to find the cartoons that are on this TV Channel. Finally, we need to select the titles of these cartoons.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'TV_Channel' where series_name = \"Sky Radio\". In the second step, we need to select id from table 'Cartoon' where Channel is in the id column of table 'TV_Channel'. In the final step, we need to select Title from table 'Cartoon'.\n\n<3> SQL Generation: Use 'where' and 'join' to find the TV Channel with the series name \"Sky Radio\", and then use 'where' and 'join' to select the titles of the cartoons on this TV Channel.\n\n", "predict": "SELECT Title FROM Cartoon AS T1 JOIN TV_Channel AS T2 ON T1.Channel  =  T2.id WHERE T2.series_name  =  \"Sky Radio\""}, {"db_id": "tvshow", "gold": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";", "question": "What is the air date of TV series with Episode \"A Love of a Lifetime\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the TV series with the episode \"A Love of a Lifetime\". Secondly, we need to retrieve the air date of this TV series.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the air_date from table 'TV_series' where the episode is \"A Love of a Lifetime\".\n\n<3> SQL Generation: Use 'where' to find the TV series with the episode \"A Love of a Lifetime\", and then select the air date.\n\n", "predict": "SELECT air_date FROM TV_series WHERE Episode = \"A Love of a Lifetime\""}, {"db_id": "tvshow", "gold": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";", "question": "What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the TV series with the episode \"A Love of a Lifetime\". Secondly, we need to retrieve the weekly rank of that TV series.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the TV series with the episode \"A Love of a Lifetime\" from the table 'TV_series' and retrieve its weekly rank.\n\n<3> SQL Generation: Use 'where' to find the TV series with the episode \"A Love of a Lifetime\" and select its weekly rank.\n\n", "predict": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\""}, {"db_id": "tvshow", "gold": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";", "question": "What is the weekly rank for the episode \"A Love of a Lifetime\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to find the weekly rank for the episode \"A Love of a Lifetime\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the weekly_rank from the 'TV_series' table where the episode title is \"A Love of a Lifetime\".\n\n<3> SQL Generation: We can use a join to combine the 'TV_series' and 'Cartoon' tables, and then filter the rows where the episode title is \"A Love of a Lifetime\". Finally, we select the weekly rank.\n\n", "predict": "SELECT weekly_rank FROM TV_series JOIN Cartoon ON TV_series.Channel = Cartoon.Channel WHERE Cartoon.Title = \"A Love of a Lifetime\""}, {"db_id": "tvshow", "gold": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";", "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the TV series with the episode \"A Love of a Lifetime\" and retrieving the TV channel of that series. We need to select the TV channel based on the episode.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the TV channel's series name from the 'TV_Channel' table based on the episode from the 'TV_series' table.\n\n<3> SQL Generation: Use 'where' to filter the TV series based on the episode and retrieve the corresponding TV channel's series name.\n\n", "predict": "SELECT TV_Channel.series_name FROM TV_series JOIN TV_Channel ON TV_series.Channel = TV_Channel.id WHERE TV_series.Episode = \"A Love of a Lifetime\""}, {"db_id": "tvshow", "gold": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";", "question": "What is the name of the series that has the episode \"A Love of a Lifetime\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the name of the series that has the episode \"A Love of a Lifetime\". We need to select the series name based on the episode.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'TV_series' and 'TV_Channel' tables based on the channel id.\n\n<3> SQL Generation: Use 'where' to filter the episode name and select the series name from the joined tables.\n\n", "predict": "SELECT TV_Channel.series_name FROM TV_series JOIN TV_Channel ON TV_series.Channel = TV_Channel.id WHERE TV_series.Episode = \"A Love of a Lifetime\""}, {"db_id": "tvshow", "gold": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";", "question": "List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the TV Channel with the series name \"Sky Radio\". Secondly, we need to list the episodes of all TV series showed on that TV Channel.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the id from the 'TV_Channel' table where series_name = \"Sky Radio\". In the second step, we need to select the Episode from the 'TV_series' table and filter by Channel.\n\n<3> SQL Generation: Use 'where' to find the TV Channel with the series name \"Sky Radio\", and then use 'where' to filter the TV series and list their episodes.\n\n", "predict": "SELECT Episode FROM TV_series WHERE Channel IN (SELECT id FROM TV_Channel WHERE series_name = \"Sky Radio\")"}, {"db_id": "tvshow", "gold": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";", "question": "What is the episode for the TV series named \"Sky Radio\"?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the episode for the TV series named \"Sky Radio\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the episode from table 'TV_series' where series_name = \"Sky Radio\".\n\n<3> SQL Generation: Use 'where' to filter the TV series named \"Sky Radio\" and select the episode.\n\n", "predict": "SELECT Episode FROM TV_series WHERE series_name = \"Sky Radio\""}, {"db_id": "tvshow", "gold": "select production_code ,  channel from cartoon order by original_air_date desc limit 1", "question": "Find the production code and channel of the most recently aired cartoon .", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the most recent air date of a cartoon. Secondly, we need to find the production code and channel of that cartoon.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the production code and channel from the 'Cartoon' table and filter by the most recent air date from the 'TV_series' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent air date from the 'TV_series' table where the series is a cartoon. Then, join the 'Cartoon' and 'TV_Channel' tables on the 'Channel' column and filter by the most recent air date. Finally, select the production code and channel of the cartoon.\n\n", "predict": "SELECT Cartoon.Production_code ,  TV_Channel.Channel FROM Cartoon JOIN TV_series ON Cartoon.id  =  TV_series.Channel JOIN TV_Channel ON Cartoon.Channel  =  TV_Channel.id WHERE Cartoon.id IN (SELECT id FROM Cartoon WHERE Cartoon.id  =  TV_series.Channel ORDER BY TV_series.Air_Date DESC LIMIT 1)"}, {"db_id": "tvshow", "gold": "select production_code ,  channel from cartoon order by original_air_date desc limit 1", "question": "What is the produdction code and channel of the most recent cartoon ?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the most recent cartoon. Secondly, we need to retrieve the production code and channel of this cartoon.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Cartoon' table for this query.\n\n<3> SQL Generation: Use 'order by' to sort the cartoons by the original air date in descending order, and then select the production code and channel of the first row.\n\n", "predict": "SELECT Production_code, Channel FROM Cartoon ORDER BY Original_air_date DESC LIMIT 1"}, {"db_id": "tvshow", "gold": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"", "question": "Find the package choice and series name of the TV channel that has high definition TV.", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: We need to find the TV channel that has high definition TV and retrieve its package choice and series name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the package option from the 'TV_Channel' table where the high definition TV is true. We also need to retrieve the series name from the 'TV_series' table where the channel matches the id of the selected TV channel.\n\n<3> SQL Generation: Use 'where' to find the TV channel that has high definition TV, and then use 'where' to retrieve the package choice and series name.\n\n", "predict": "SELECT T1.package_option, T2.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.channel WHERE T1.high_definition_TV = true"}, {"db_id": "tvshow", "gold": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"", "question": "What are the package options and the name of the series for the TV Channel that supports high definition TV?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter the TV Channels that support high definition TV. Secondly, we need to retrieve the package options and the names of the series for those TV Channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select id from table 'TV_Channel' where Hight_definition_TV = true. Then, we need to retrieve the package options from table 'TV_Channel' and the names of the series from table 'TV_series'.\n\n<3> SQL Generation: Use 'where' to filter the TV Channels that support high definition TV, and then select the package options and the names of the series.\n\n", "predict": "SELECT package_option, series_name FROM TV_Channel JOIN TV_series ON TV_Channel.id = TV_series.Channel WHERE Hight_definition_TV = true"}, {"db_id": "tvshow", "gold": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'", "question": "which countries' tv channels are playing some cartoon written by Todd Casey?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoon written by Todd Casey. Secondly, we need to identify the TV channels that are playing that cartoon. Lastly, we need to determine the countries where those TV channels are located.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the cartoon ID from the 'Cartoon' table where the written_by column matches \"Todd Casey\". Then, we need to find the TV channels that are playing that cartoon by matching the cartoon ID in the 'TV_series' table. Finally, we need to retrieve the countries from the 'TV_Channel' table based on the channel IDs found in the previous step.\n\n<3> SQL Generation: Use 'where' to filter the cartoon written by Todd Casey, then use 'join' to link the 'TV_series' table with the 'TV_Channel' table based on the channel IDs. Finally, select the distinct countries from the 'TV_Channel' table.\n\n", "predict": "SELECT DISTINCT Country FROM TV_Channel JOIN TV_series ON TV_Channel.id = TV_series.Channel JOIN Cartoon ON Cartoon.id = TV_series.id WHERE Cartoon.Written_by = \"Todd Casey\""}, {"db_id": "tvshow", "gold": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'", "question": "What are the countries that have cartoons on TV that were written by Todd Casey?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoons on TV that were written by Todd Casey. Secondly, we need to retrieve the countries where these cartoons are aired.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'id' column from the 'TV_Channel' table where the cartoons were written by Todd Casey. Then, we need to filter the 'Country' column from the 'TV_Channel' table based on the selected channels.\n\n<3> SQL Generation: Use 'where' to find the channels where the cartoons were written by Todd Casey, and then select the countries where these channels are aired.\n\n", "predict": "SELECT DISTINCT Country FROM TV_Channel WHERE id IN (SELECT Channel FROM Cartoon WHERE Written_by = 'Todd Casey')"}, {"db_id": "tvshow", "gold": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'", "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the countries whose TV channels are not playing any cartoon written by Todd Casey. We need to filter out the TV channels that are playing cartoons written by Todd Casey and return the remaining countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter out TV channels playing cartoons written by Todd Casey, we need the 'TV_Channel' and 'Cartoon' tables.\n\n<3> SQL Generation: We can use a subquery to select the channel IDs of TV channels playing cartoons written by Todd Casey. Then, we can use 'not in' to filter out the TV channels playing those cartoons and select the countries associated with the remaining TV channels.\n\n", "predict": "SELECT Country FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Written_by = 'Todd Casey')"}, {"db_id": "tvshow", "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'", "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoons directed by Ben Jones and Michael Chang. Secondly, we need to find the tv channel that is playing those cartoons. Lastly, we need to select the series name and country of that tv channel.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select cartoons directed by Ben Jones and Michael Chang from the 'Cartoon' table. Then, we need to find the tv channel playing those cartoons from the 'TV_Channel' table. Finally, we need to select the series name and country from the 'TV_Channel' table.\n\n<3> SQL Generation: Use 'where' to filter cartoons directed by Ben Jones and Michael Chang from the 'Cartoon' table. Then, use 'where' to find the tv channel playing those cartoons from the 'TV_Channel' table. Finally, select the series name and country from the 'TV_Channel' table.\n\n", "predict": "SELECT T2.series_name, T2.country FROM Cartoon AS T1 JOIN TV_Channel AS T2 ON T1.Channel = T2.id WHERE T1.Directed_by = \"Ben Jones\" OR T1.Directed_by = \"Michael Chang\""}, {"db_id": "tvshow", "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'", "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires filtering on TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang. Firstly, we need to identify the TV channels that are playing cartoons directed by Ben Jones. Secondly, we need to identify the TV channels that are playing cartoons directed by Michael Chang. Finally, we need to select the series name and country of these TV channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need information from the 'Cartoon' table and the 'TV_Channel' table, we need to consider these tables.\n\n<3> SQL Generation: Use 'where' to filter cartoons directed by Ben Jones and select the corresponding TV channels. Then, use 'where' to filter cartoons directed by Michael Chang and select the corresponding TV channels. Finally, select the series name and country of these TV channels.\n\n", "predict": "SELECT series_name, country FROM TV_Channel WHERE id IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones') AND id IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Michael Chang')"}, {"db_id": "tvshow", "gold": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'", "question": "What is the pixel aspect ratio and country of origin for all TV channels that do not use English?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to filter TV channels that do not use English. Secondly, we need to select the pixel aspect ratio and country of origin for the filtered TV channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'TV_Channel' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter TV channels that do not use English, and then select the pixel aspect ratio and country of origin for the filtered TV channels.\n\n", "predict": "SELECT pixel_aspect_ratio_PAR, country FROM TV_Channel WHERE language != 'English'"}, {"db_id": "tvshow", "gold": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2", "question": "find id of the tv channels that from the countries where have more than two tv channels.", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding the TV channels from countries that have more than two TV channels. Firstly, we need to identify the countries that have more than two TV channels. Secondly, we need to find the TV channels from those countries and select their IDs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the IDs from the 'TV_Channel' table where the country has more than two TV channels.\n\n<3> SQL Generation: Use 'where' and 'group by' to filter the countries that have more than two TV channels. Then, use 'where' to find the TV channels from those countries and select their IDs.\n\n", "predict": "SELECT id FROM TV_Channel WHERE Country IN (SELECT Country FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2)"}, {"db_id": "tvshow", "gold": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2", "question": "What are the ids of all tv channels that have more than 2 TV channels?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: The query requires finding TV channels that have more than 2 TV channels. We need to select the ids of these TV channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the ids from the 'TV_Channel' table.\n\n<3> SQL Generation: Use 'where' to filter TV channels with more than 2 TV channels, and select the ids.\n\n", "predict": "SELECT id FROM TV_Channel GROUP BY id HAVING COUNT(*) > 2"}, {"db_id": "tvshow", "gold": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'", "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "<1> Decomposition: Firstly, we need to find the cartoons directed by Ben Jones. Secondly, we need to filter the TV channels that do not have any cartoons directed by Ben Jones. Finally, we need to retrieve the ids of the filtered TV channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select id from table 'TV_Channel' where there are no corresponding entries in table 'Cartoon' with Directed_by = \"Ben Jones\".\n\n<3> SQL Generation: Use 'where' and 'not exists' to find the TV channels that do not have any cartoons directed by Ben Jones, and then select the ids of the filtered TV channels.\n\n", "predict": "SELECT id FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = \"Ben Jones\")"}, {"db_id": "poker_player", "gold": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000", "question": "What is the maximum number of final tables made among poker players with earnings less than 200000?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter poker players based on their earnings. Secondly, we need to calculate the maximum number of final tables made for the filtered poker players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Poker_Player_ID from table 'poker_player' where Earnings < 200000. In the second step, we need to select the maximum value of Final_Table_Made from table 'poker_player'.\n\n<3> SQL Generation: Use 'where' to filter poker players with earnings less than 200000, and then use 'max' to calculate the maximum number of final tables made.\n\n", "predict": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"}, {"db_id": "poker_player", "gold": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000", "question": "Return the maximum final tables made across all poker players who have earnings below 200000.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter poker players based on their earnings being below 200000. Secondly, we need to find the maximum final tables made among the filtered players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Final_Table_Made' column from the 'poker_player' table and filter based on earnings from the 'poker_player' table.\n\n<3> SQL Generation: Use 'where' to filter poker players based on their earnings being below 200000, and then use 'max' to find the maximum final tables made among the filtered players.\n\n", "predict": "SELECT MAX(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000"}, {"db_id": "poker_player", "gold": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000", "question": "What are the names of poker players whose earnings is higher than 300000?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on poker players whose earnings are higher than 300000. Firstly, we need to identify the poker players with earnings higher than 300000. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the earnings are in the 'poker_player' table and the names are in the 'people' table, we need to use these two tables.\n\n<3> SQL Generation: Use 'where' to filter poker players with earnings higher than 300000, and then select their names.\n\n", "predict": "SELECT T2.Name FROM poker_player AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Earnings > 300000"}, {"db_id": "poker_player", "gold": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000", "question": "Give the names of poker players who have earnings above 300000.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter poker players based on their earnings, selecting only players with earnings above 300000. Secondly, we need to retrieve the names of these players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Name column from the people table and filter poker players based on their earnings from the poker_player table.\n\n<3> SQL Generation: Use 'where' to filter poker players with earnings above 300000, and then join the people and poker_player tables on the People_ID column to retrieve the player names.\n\n", "predict": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"}, {"db_id": "poker_player", "gold": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1", "question": "What is the birth date of the poker player with the lowest earnings?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the poker player with the lowest earnings. Secondly, we need to retrieve the birth date of this poker player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the minimum earnings from table 'poker_player'. In the second step, we need to filter the poker player with the minimum earnings and retrieve the corresponding People_ID. Finally, we need to select the birth date from table 'people' based on the People_ID.\n\n<3> SQL Generation: Use 'where' to find the poker player with the lowest earnings, and then use 'where' to filter the People_ID and select the corresponding birth date.\n\n", "predict": "SELECT birth_date FROM people WHERE People_ID = (SELECT People_ID FROM poker_player ORDER BY Earnings LIMIT 1)"}, {"db_id": "poker_player", "gold": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1", "question": "Return the birth date of the poker player with the lowest earnings.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the poker player with the lowest earnings. Secondly, we need to select the birth date of the selected poker player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Birth_Date' column from the 'people' table where the 'Poker_Player_ID' column is the ID of the poker player with the lowest earnings.\n\n<3> SQL Generation: Use 'where' to filter poker players with the lowest earnings, and then select the birth date.\n\n", "predict": "SELECT Birth_Date FROM people JOIN poker_player ON people.People_ID = poker_player.People_ID ORDER BY Earnings ASC LIMIT 1"}, {"db_id": "poker_player", "gold": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "question": "What is the money rank of the tallest poker player?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the tallest poker player. Secondly, we need to retrieve the money rank of that player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Poker_Player_ID from the 'poker_player' table where the Height is the maximum value. Then, we need to retrieve the Money_Rank from the 'poker_player' table for the selected player.\n\n<3> SQL Generation: Use 'max' to find the maximum Height, and then use 'where' to filter the player with the maximum Height. Finally, select the Money_Rank for that player.\n\n", "predict": "SELECT Money_Rank FROM poker_player WHERE People_ID IN (SELECT People_ID FROM people WHERE Height = (SELECT MAX(Height) FROM people))"}, {"db_id": "poker_player", "gold": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "question": "Return the money rank of the poker player with the greatest height.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the poker player with the greatest height. Secondly, we need to select the money rank of the selected poker player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the height and money rank of the poker player, we need to join the 'people' and 'poker_player' tables on the 'People_ID' column.\n\n<3> SQL Generation: Use 'order by' and 'limit' to find the poker player with the greatest height, and then select the money rank.\n\n", "predict": "SELECT Money_Rank FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY Height DESC LIMIT 1"}, {"db_id": "poker_player", "gold": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200", "question": "What is the average earnings of poker players with height higher than 200?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter poker players with height higher than 200. Secondly, we need to calculate the average earnings of these poker players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Earnings from table 'poker_player' and filter by height.\n\n<3> SQL Generation: Use 'where' to filter poker players with height higher than 200, and then use 'avg' to calculate the average earnings.\n\n", "predict": "SELECT avg(Earnings) FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE Height > 200"}, {"db_id": "poker_player", "gold": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200", "question": "Give average earnings of poker players who are taller than 200.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on poker players' height and calculating the average earnings of those players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Earnings' column from the 'poker_player' table and the 'Height' column from the 'people' table. We also need to join the two tables on the 'People_ID' column.\n\n<3> SQL Generation: Use 'where' to filter poker players based on their height being taller than 200, and then use 'avg' to calculate the average earnings of those players.\n\n", "predict": "SELECT avg(poker_player.Earnings) FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE people.Height > 200"}, {"db_id": "poker_player", "gold": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2", "question": "Return the nationalities for which there are two or more people.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "<1> Decomposition: We need to find the nationalities for which there are two or more people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Nationality' column from the 'people' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter the nationalities for which there are two or more people.\n\n", "predict": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*) >= 2"}, {"db_id": "voter_1", "gold": "SELECT max(created) FROM votes WHERE state  =  'CA'", "question": "What is last date created of votes from the state 'CA'?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: Firstly, we need to filter votes based on the state 'CA'. Secondly, we need to select the last date created of the filtered votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the created column from table 'VOTES' and filter by state.\n\n<3> SQL Generation: Use 'where' to filter votes from the state 'CA', and then select the maximum created date.\n\n", "predict": "SELECT MAX(created) FROM votes WHERE state = 'CA'"}, {"db_id": "voter_1", "gold": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'", "question": "What are the names of the contestants whose names are not 'Jessie Alloway'", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: The query requires filtering on the contestant_name column in the CONTESTANTS table. We need to select the names of the contestants that have a name different from 'Jessie Alloway'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the CONTESTANTS table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the contestants where the name is not 'Jessie Alloway' and select the names of those contestants.\n\n", "predict": "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"}, {"db_id": "voter_1", "gold": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2", "question": "What are the contestant numbers and names of the contestants who had at least two votes?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: Firstly, we need to count the number of votes for each contestant. Secondly, we need to filter the contestants who had at least two votes. Finally, we need to select the contestant numbers and names of the filtered contestants.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the contestant numbers and names from the 'CONTESTANTS' table and filter by the number of votes from the 'VOTES' table.\n\n<3> SQL Generation: Use 'group by' and 'count' to count the number of votes for each contestant. Then, use 'having' to filter the contestants who had at least two votes. Finally, select the contestant numbers and names of the filtered contestants.\n\n", "predict": "SELECT contestant_number, contestant_name FROM CONTESTANTS JOIN VOTES ON CONTESTANTS.contestant_number = VOTES.contestant_number GROUP BY contestant_number, contestant_name HAVING COUNT(*) >= 2;"}, {"db_id": "voter_1", "gold": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1", "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the contestants who received votes. Secondly, we need to find the contestant who received the least votes and select their contestant number and name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select contestant_number and contestant_name from table 'CONTESTANTS' and filter based on votes received from table 'VOTES'.\n\n<3> SQL Generation: Use 'group by' to group the votes by contestant_number and select the contestant_number and contestant_name. Then, use 'order by' to sort the votes in ascending order and select the first row.\n\n", "predict": "SELECT contestant_number, contestant_name FROM CONTESTANTS INNER JOIN VOTES ON CONTESTANTS.contestant_number = VOTES.contestant_number GROUP BY contestant_number, contestant_name ORDER BY COUNT(*) ASC LIMIT 1"}, {"db_id": "voter_1", "gold": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'", "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: Firstly, we need to filter votes based on the contestant name being 'Tabatha Gehling'. Secondly, we need to select the create dates, states, and phone numbers of the filtered votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to consider the 'VOTES' and 'CONTESTANTS' tables for this query.\n\n<3> SQL Generation: Use 'where' to filter votes with the contestant name 'Tabatha Gehling', and then select the create dates, states, and phone numbers of the filtered votes.\n\n", "predict": "SELECT created, state, phone_number FROM VOTES WHERE contestant_number = (SELECT contestant_number FROM CONTESTANTS WHERE contestant_name = 'Tabatha Gehling')"}, {"db_id": "voter_1", "gold": "select contestant_name from contestants where contestant_name like \"%al%\"", "question": "Return the names of the contestants whose names contain the substring 'Al' .", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "<1> Decomposition: The query requires finding contestants whose names contain the substring 'Al'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'CONTESTANTS' table.\n\n<3> SQL Generation: We can use the 'LIKE' operator in the 'WHERE' clause to filter contestants whose names contain the substring 'Al'.\n\n", "predict": "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%Al%'"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE IndepYear  >  1950", "question": "What are the names of all the countries that became independent after 1950?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding countries that became independent after 1950 and retrieving their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'country' table and the 'IndepYear' column.\n\n<3> SQL Generation: Use 'where' to filter countries that became independent after 1950. Finally, select the names of these countries.\n\n", "predict": "SELECT Name FROM country WHERE IndepYear > 1950"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE IndepYear  >  1950", "question": "Give the names of the nations that were founded after 1950.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on nations that were founded after 1950. Firstly, we need to identify the nations that were founded after 1950. Secondly, we need to select the names of these nations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Name' column from the 'country' table, we only need to use the 'country' table.\n\n<3> SQL Generation: Use 'where' to filter nations based on their founding year, selecting nations that were founded after 1950. Then, select the names of these nations.\n\n", "predict": "SELECT Name FROM country WHERE IndepYear > 1950"}, {"db_id": "world_1", "gold": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"", "question": "How many countries have a republic as their form of government?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries based on their form of government being a republic. Secondly, we need to count the number of countries that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the countries from table 'country' where the government form is 'republic'.\n\n<3> SQL Generation: Use 'where' to filter countries where the government form is 'republic' and then use 'count' to count the number of countries.\n\n", "predict": "SELECT count(*) FROM country WHERE government_form  =  \"republic\""}, {"db_id": "world_1", "gold": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"", "question": "How many countries have governments that are republics?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the governments that are republics. Secondly, we need to count the number of countries with such governments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the countries from table 'country' where the government form is 'Republic'. In the second step, we need to count the number of countries from the first step.\n\n<3> SQL Generation: Use 'where' to find the countries with governments that are republics, and then use 'count' to count the number of countries.\n\n", "predict": "SELECT count(*) FROM country WHERE governmentform = 'Republic'"}, {"db_id": "world_1", "gold": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"", "question": "What is the total surface area of the countries in the Caribbean region?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries in the Caribbean region. Secondly, we need to calculate the total surface area of these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SurfaceArea column from the 'country' table and filter by the Region column where it is equal to 'Caribbean'.\n\n<3> SQL Generation: Use 'where' to filter countries in the Caribbean region, and then use 'sum' to calculate the total surface area of these countries.\n\n", "predict": "SELECT sum(SurfaceArea) FROM country WHERE Region = 'Caribbean'"}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"", "question": "What is the average expected life expectancy for countries in the region of Central Africa?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries in the region of Central Africa. Firstly, we need to identify the countries in the region of Central Africa. Secondly, we need to calculate the average expected life expectancy for those countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where Region = 'Central Africa'. In the second step, we need to select LifeExpectancy from table 'country' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter countries in the region of Central Africa, and then use 'avg' to calculate the average expected life expectancy for the selected countries.\n\n", "predict": "SELECT avg(LifeExpectancy) FROM country WHERE Region = 'Central Africa'"}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"", "question": "How long is the people\u2019s average life expectancy in Central Africa?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires calculating the average life expectancy of people in Central Africa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'country' table to filter countries in Central Africa and retrieve the population and life expectancy columns.\n\n<3> SQL Generation: Use 'where' to filter countries in Central Africa, and then calculate the average life expectancy of the selected countries.\n\n", "predict": "SELECT avg(LifeExpectancy) FROM country WHERE Region = 'Central Africa'"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1", "question": "What is the name of country that has the shortest life expectancy in Asia?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries in Asia. Secondly, we need to find the country with the shortest life expectancy among these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Name' column from the 'country' table to retrieve the country names. We also need to filter countries in Asia, so we need to use the 'Continent' column in the 'country' table. Additionally, we need to consider the 'LifeExpectancy' column to find the country with the shortest life expectancy.\n\n<3> SQL Generation: Use 'where' to filter countries in Asia, and then use 'order by' and 'limit' to find the country with the shortest life expectancy.\n\n", "predict": "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1", "question": "Give the name of the country in Asia with the lowest life expectancy.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the countries in Asia. Secondly, we need to find the country with the lowest life expectancy among these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Name' and 'LifeExpectancy' columns from the 'country' table.\n\n<3> SQL Generation: Use 'where' to filter countries in Asia, and then use 'order by' and 'limit' to find the country with the lowest life expectancy.\n\n", "predict": "SELECT Name FROM country WHERE Continent = 'Asia' ORDER BY LifeExpectancy ASC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"", "question": "What is the average life expectancy in African countries that are republics?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on African countries that are republics and calculating the average life expectancy in those countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'country' table to filter African countries and check if they are republics. We also need the 'countrylanguage' table to check the official language of the country.\n\n<3> SQL Generation: Use 'where' to filter African countries and check if they are republics. Then, calculate the average life expectancy in those countries.\n\n", "predict": "SELECT avg(LifeExpectancy) FROM country WHERE Continent = \"Africa\" AND GovernmentForm = \"Republic\""}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"", "question": "Give the average life expectancy for countries in Africa which are republics?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries in Africa that are republics. Firstly, we need to identify the countries in Africa. Secondly, we need to filter countries that are republics. Finally, we calculate the average life expectancy for the remaining countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Name from table 'country' where Continent = 'Africa' and GovernmentForm = 'Republic'. Then, we need to calculate the average LifeExpectancy from table 'country'.\n\n<3> SQL Generation: Use 'where' to filter countries in Africa, and then use 'and' to filter countries that are republics. Finally, calculate the average LifeExpectancy for the selected countries.\n\n", "predict": "SELECT avg(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'"}, {"db_id": "world_1", "gold": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"", "question": "How many people live in Gelderland district?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of people who live in the Gelderland district.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the sum of the 'Population' column from the 'city' table where the district is Gelderland.\n\n<3> SQL Generation: Use 'where' to filter cities in the Gelderland district and sum their populations.\n\n", "predict": "SELECT sum(Population) FROM city WHERE District = \"Gelderland\";"}, {"db_id": "world_1", "gold": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"", "question": "What is the total population of Gelderland district?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires retrieving the total population of the Gelderland district. We need to identify the district with the name \"Gelderland\" and retrieve its population.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'city' table to retrieve the population of the Gelderland district.\n\n<3> SQL Generation: Use 'where' to filter the rows where the district is \"Gelderland\" and then use 'sum' to calculate the total population of the Gelderland district.\n\n", "predict": "SELECT sum(Population) FROM city WHERE District = \"Gelderland\""}, {"db_id": "world_1", "gold": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"", "question": "What is the average GNP and total population in all nations whose government is US territory?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter nations based on their government being US territory. Secondly, we need to calculate the average GNP and total population of the selected nations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'country' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter nations with a government that is US territory, and then use 'avg' and 'sum' to calculate the average GNP and total population of the selected nations.\n\n", "predict": "SELECT avg(GNP), sum(Population) FROM country WHERE GovernmentForm = \"US territory\""}, {"db_id": "world_1", "gold": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"", "question": "Give the mean GNP and total population of nations which are considered US territory.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to identify the nations that are considered US territory. Secondly, we need to calculate the mean GNP and total population of these nations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the Code from table 'country' where Region = \"US Territory\". In the second step, we need to calculate the mean GNP and total population from table 'country' based on the codes obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the codes of the nations that are considered US territory, and then use 'where' to calculate the mean GNP and total population based on these codes.\n\n", "predict": "SELECT AVG(GNP) AS mean_GNP, SUM(Population) AS total_population FROM country WHERE Region = \"US Territory\""}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"", "question": "How many type of governments are in Africa?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of types of governments in Africa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of distinct government forms from the 'country' table where the continent is Africa.\n\n<3> SQL Generation: Use 'where' to filter countries in the continent of Africa, select distinct government forms, and count them.\n\n", "predict": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"", "question": "How many different forms of governments are there in Africa?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of different forms of governments in Africa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the distinct forms of government from the 'country' table where the continent is 'Africa'.\n\n<3> SQL Generation: Use 'where' to filter the countries in Africa, select the distinct forms of government, and count them.\n\n", "predict": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa'"}, {"db_id": "world_1", "gold": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"", "question": "What is the total number of languages used in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding the total number of languages used in Aruba.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Language' column from the 'countrylanguage' table where the 'CountryCode' is 'ABW' (the code for Aruba).\n\n<3> SQL Generation: Use 'where' to filter the rows where the 'CountryCode' is 'ABW', and then use 'count' to calculate the total number of languages used in Aruba.\n\n", "predict": "SELECT count(*) FROM countrylanguage WHERE CountryCode  =  'ABW'"}, {"db_id": "world_1", "gold": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"", "question": "How many languages are spoken in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of languages that are spoken in Aruba.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Language' column from the 'countrylanguage' table and filter by the 'CountryCode' column from the 'country' table.\n\n<3> SQL Generation: Use 'where' to filter languages that are spoken in Aruba and count them.\n\n", "predict": "SELECT count(*) FROM countrylanguage WHERE CountryCode = (SELECT Code FROM country WHERE Name = 'Aruba')"}, {"db_id": "world_1", "gold": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"", "question": "What is the number of distinct continents where Chinese is spoken?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding the number of distinct continents where Chinese is spoken. We need to filter the languages to only include Chinese and then count the number of distinct continents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'country' table to get the continents and the 'countrylanguage' table to filter the languages.\n\n<3> SQL Generation: Use 'where' to filter the languages to only include Chinese, then use 'distinct' and 'count' to calculate the number of distinct continents.\n\n", "predict": "SELECT COUNT(DISTINCT Continent) FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Chinese')"}, {"db_id": "world_1", "gold": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"", "question": "How many continents speak Chinese?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of continents that speak Chinese. We need to filter continents based on the language spoken in the 'countrylanguage' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Continent column from the 'country' table and filter based on the Language column in the 'countrylanguage' table where Language = 'Chinese'.\n\n<3> SQL Generation: Use 'where' to filter continents based on the Language column in the 'countrylanguage' table where Language = 'Chinese' and count the number of continents.\n\n", "predict": "SELECT count(DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese'"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1", "question": "Which languages are spoken by only one country in republic governments?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries that have a republic government. Secondly, we need to find the languages spoken by only one country among these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the country codes from the 'country' table where the government form is 'republic'. In the second step, we need to join the 'countrylanguage' table with the 'country' table on the 'CountryCode' column and select the languages spoken by only one country.\n\n<3> SQL Generation: Use 'where' to filter countries with a republic government, join the 'countrylanguage' and 'country' tables on the corresponding columns, group by language, and select the languages spoken by only one country.\n\n", "predict": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(T2.Language)  =  1"}, {"db_id": "world_1", "gold": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1", "question": "Find the city with the largest population that uses English.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: We need to find the city with the largest population that uses English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the city with the largest population from the 'city' table and filter the cities that use English from the 'countrylanguage' table.\n\n<3> SQL Generation: Use 'where' to filter the cities that use English from the 'countrylanguage' table, then use 'order by' and 'limit' to select the city with the largest population from the 'city' table.\n\n", "predict": "SELECT city.Name FROM city JOIN countrylanguage ON city.CountryCode = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' ORDER BY city.Population DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1", "question": "What are the name, population, and life expectancy of the largest Asian country by land?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the largest Asian country by land. Secondly, we need to select the name, population, and life expectancy of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to consider the 'country' table and its related tables. We can join the 'country' table with the 'city' table on the 'CountryCode' column to get the population. We can also join the 'country' table with the 'countrylanguage' table on the 'CountryCode' column to get the official language.\n\n<3> SQL Generation: Use 'where' to filter countries by continent (Asia) and order them by surface area in descending order. Then, select the name, population, and life expectancy of the first country in the result.\n\n", "predict": "SELECT name, population, lifeexpectancy FROM country WHERE continent = 'Asia' ORDER BY surfacearea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")", "question": "What is average life expectancy in the countries where English is not the official language?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries where English is not the official language. Firstly, we need to identify the countries where English is the official language. Secondly, we need to calculate the average life expectancy in the countries that are not in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CountryCode from table 'countrylanguage' where Language = 'English' and IsOfficial = 'T'. In the second step, we need to select LifeExpectancy from table 'country' and filter by CountryCode.\n\n<3> SQL Generation: Use 'where' to filter countries where English is the official language, and then use 'not in' to filter countries that are not in the first step. Finally, calculate the average life expectancy for the selected countries.\n\n", "predict": "SELECT avg(LifeExpectancy) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language  =  \"English\" AND IsOfficial  =  \"T\")"}, {"db_id": "world_1", "gold": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")", "question": "Give the mean life expectancy of countries in which English is not the official language.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries where English is not the official language. Secondly, we need to calculate the mean life expectancy of the selected countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the life expectancy from the 'country' table and filter by the official language in the 'countrylanguage' table.\n\n<3> SQL Generation: Use 'where' to filter countries where English is not the official language, and then use 'avg' to calculate the mean life expectancy of the selected countries.\n\n", "predict": "SELECT AVG(LifeExpectancy) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"", "question": "What is the official language spoken in the country whose head of state is Beatrix?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the head of state column in the country table. We need to find the country where the head of state is \"Beatrix\" and retrieve the official language spoken in that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the country table to filter countries based on the head of state and the countrylanguage table to retrieve the official language.\n\n<3> SQL Generation: Use the 'where' clause to filter the country where the head of state is \"Beatrix\" and select the official language spoken in that country.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode = (SELECT Code FROM country WHERE HeadOfState = \"Beatrix\") AND IsOfficial = \"T\""}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"", "question": "What is the official language used in the country the name of whose head of state is Beatrix.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding the country whose head of state is Beatrix and retrieving the official language used in that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the CountryCode from the 'country' table based on the head of state, and then select the Language from the 'countrylanguage' table based on the CountryCode.\n\n<3> SQL Generation: Use 'where' to filter the country based on the head of state being Beatrix, and then select the official language from the 'countrylanguage' table.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode = (SELECT Code FROM country WHERE HeadOfState = \"Beatrix\" AND IsOfficial = \"T\")"}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"", "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter countries that were founded before 1930. Secondly, we need to find the unique official languages spoken in these countries. Finally, we need to calculate the total number of these unique official languages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'country' table to filter countries founded before 1930, and the 'countrylanguage' table to find the unique official languages.\n\n<3> SQL Generation: Use 'where' to filter countries founded before 1930, then use 'join' to link the 'country' and 'countrylanguage' tables based on the CountryCode. Finally, use 'distinct' and 'count' to calculate the total number of unique official languages spoken in these countries.\n\n", "predict": "SELECT count(DISTINCT Language) FROM country JOIN countrylanguage ON country.Code  =  countrylanguage.CountryCode WHERE country.IndepYear  <  1930 AND countrylanguage.IsOfficial  =  \"T\""}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"", "question": "For the countries founded before 1930, what is the total number of distinct official languages?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the countries that were founded before 1930. Secondly, we need to find the distinct official languages of these countries. Finally, we need to calculate the total number of distinct official languages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where IndepYear is less than 1930. In the second step, we need to select distinct Language from table 'countrylanguage' where IsOfficial is true and CountryCode matches the Code found in the first step.\n\n<3> SQL Generation: Use 'where' to find the countries founded before 1930, then use 'where' to find the distinct official languages of these countries, and finally use 'count' to calculate the total number of distinct official languages.\n\n", "predict": "SELECT count(DISTINCT Language) FROM countrylanguage WHERE IsOfficial  =  \"T\" AND CountryCode IN (SELECT Code FROM country WHERE IndepYear < 1930)"}, {"db_id": "world_1", "gold": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "question": "Which cities are in European countries where English is not the official language?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding cities in European countries where English is not the official language. Firstly, we need to identify the European countries. Secondly, we need to filter out the countries where English is the official language. Finally, we need to find the cities in the remaining countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'city', 'country', and 'countrylanguage' tables.\n\n<3> SQL Generation: Use 'where' to filter European countries, and then use 'not in' to filter out the countries where English is the official language. Finally, select the cities in the remaining countries.\n\n", "predict": "SELECT city.Name FROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = \"Europe\" \nAND countrylanguage.Language != \"English\" \nAND countrylanguage.IsOfficial = \"T\""}, {"db_id": "world_1", "gold": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "question": "What are the names of cities in Europe for which English is not the official language?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter cities based on their continent being \"Europe\" and the official language not being English. Secondly, we need to select the names of these cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'city' table and filter based on the 'CountryCode' column. We also need to join the 'city' table with the 'country' table using the 'CountryCode' column.\n\n<3> SQL Generation: Use 'where' to filter cities based on their continent being \"Europe\" and the official language not being English, and select their names.\n\n", "predict": "SELECT city.Name FROM city JOIN country ON city.CountryCode = country.Code WHERE country.Continent = \"Europe\" AND NOT EXISTS (SELECT * FROM countrylanguage WHERE countrylanguage.CountryCode = country.Code AND countrylanguage.Language = \"English\" AND countrylanguage.IsOfficial = \"T\")"}, {"db_id": "world_1", "gold": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  \"asia\"", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires finding the unique cities in Asian countries where Chinese is the official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the cities from the 'city' table where the country is in Asia and the language is Chinese and is official.\n\n<3> SQL Generation: Use 'where' to filter the rows where the country is in Asia, the language is Chinese, and is official, and then select the unique cities.\n\n", "predict": "SELECT DISTINCT city.Name FROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = \"Asia\" AND countrylanguage.Language = \"Chinese\" AND countrylanguage.IsOfficial = \"T\""}, {"db_id": "world_1", "gold": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the country with the smallest population. Secondly, we need to retrieve the name, independence year, and surface area of this country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name, independence year, and surface area from the 'country' table and filter by the country with the smallest population.\n\n<3> SQL Generation: Use 'where' to filter the country with the smallest population and select the name, independence year, and surface area.\n\n", "predict": "SELECT name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)"}, {"db_id": "world_1", "gold": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the country with the lowest population. Secondly, we need to select the name, year of independence, and surface area of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name, indepYear, and surfaceArea from table 'country' and find the country with the lowest population.\n\n<3> SQL Generation: Use 'min' to find the country with the lowest population, and then select the name, indepYear, and surfaceArea of that country.\n\n", "predict": "SELECT name, indepYear, surfaceArea FROM country WHERE population = (SELECT MIN(population) FROM country)"}, {"db_id": "world_1", "gold": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries that speak more than 2 languages. We need to select the names of these countries and the number of languages they speak.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the country names from the 'country' table and count the number of languages from the 'countrylanguage' table.\n\n<3> SQL Generation: Use a subquery to count the number of languages for each country and filter countries that speak more than 2 languages. Then, select the country names and the number of languages.\n\n", "predict": "SELECT country.Name, COUNT(countrylanguage.Language) AS num_languages \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nGROUP BY country.Name \nHAVING num_languages > 2"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average life expectancy for each government form. Secondly, we need to filter government forms whose average life expectancy is longer than 72. Finally, we need to select the government form name and total population for these government forms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select government form name and total population from the 'country' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average life expectancy for each government form, and then use 'where' to filter government forms whose average life expectancy is longer than 72. Finally, select the government form name and total population for these government forms.\n\n", "predict": "SELECT governmentform ,  SUM(population) FROM country WHERE governmentform IN (SELECT governmentform FROM country GROUP BY governmentform HAVING AVG(lifeexpectancy) > 72) GROUP BY governmentform"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average life expectancy for each government form. Secondly, we need to filter government forms with an average life expectancy greater than 72. Finally, we need to calculate the total population for each government form that meets the condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select government forms and population from the 'country' table and average life expectancy from the 'countrylanguage' table.\n\n<3> SQL Generation: Use 'join' to link the 'country' and 'countrylanguage' tables based on the country code. Then, use 'group by' to group the data by government form. Use 'having' to filter government forms with an average life expectancy greater than 72. Finally, use 'sum' to calculate the total population for each government form.\n\n", "predict": "SELECT c.GovernmentForm, SUM(c.Population) AS TotalPopulation \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY c.GovernmentForm \nHAVING AVG(cl.LifeExpectancy) > 72"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average life expectancy for each continent. Secondly, we need to filter continents where the average life expectancy is shorter than 72. Finally, we need to find the total population for each of these continents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the average life expectancy from the 'country' table and calculate it for each continent. Then, we need to filter continents based on the average life expectancy and find the total population from the 'country' table.\n\n<3> SQL Generation: Use 'select continent, avg(lifeexpectancy)' to calculate the average life expectancy for each continent. Then, use 'where' to filter continents where the average life expectancy is shorter than 72. Finally, use 'select continent, sum(population)' to find the total population for each of these continents.\n\n", "predict": "SELECT continent, avg(lifeexpectancy), sum(population) FROM country GROUP BY continent HAVING avg(lifeexpectancy) < 72"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average life expectancy for each continent. Secondly, we need to filter continents with an average life expectancy less than 72. Finally, we need to retrieve the different continents and their corresponding total population and average life expectancy.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Continent from table 'country' and retrieve Population and LifeExpectancy from the same table.\n\n<3> SQL Generation: Use 'group by' to calculate the average life expectancy for each continent. Then, use 'having' to filter continents with an average life expectancy less than 72. Finally, select the different continents and their corresponding total population and average life expectancy.\n\n", "predict": "SELECT Continent, SUM(Population) AS Total_Population, AVG(LifeExpectancy) AS Average_Life_Expectancy FROM country GROUP BY Continent HAVING AVG(LifeExpectancy) < 72"}, {"db_id": "world_1", "gold": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"", "question": "how many countries are in Asia?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the countries in Asia. Secondly, we need to count the number of these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Code' column from the 'country' table where the 'Continent' column is 'Asia'.\n\n<3> SQL Generation: Use 'where' to find the countries in Asia, and then use 'count' to count the number of these countries.\n\n", "predict": "SELECT COUNT(*) FROM country WHERE Continent = 'Asia'"}, {"db_id": "world_1", "gold": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"", "question": "Count the number of countries in Asia.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of countries in Asia. We need to filter out the countries that are in Asia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the countries from the 'country' table and filter by the Continent column.\n\n<3> SQL Generation: Use 'where' to filter out the countries in Asia and count the remaining countries.\n\n", "predict": "SELECT count(*) FROM country WHERE Continent = 'Asia'"}, {"db_id": "world_1", "gold": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on countries in North America with a surface area greater than 3000. Firstly, we need to identify the countries in North America with a surface area greater than 3000. Secondly, we need to calculate the total population and average surface area of those countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where Continent = 'North America' and SurfaceArea > 3000. In the second step, we need to calculate the total population and average surface area from table 'country' based on the selected country codes.\n\n<3> SQL Generation: Use 'where' to filter countries in North America with a surface area greater than 3000, and then use 'sum' and 'avg' to calculate the total population and average surface area.\n\n", "predict": "SELECT sum(Population), avg(SurfaceArea) FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000"}, {"db_id": "world_1", "gold": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "question": "What are the cities whose population is between 160000 and 900000?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the population column in the city table. We need to select the cities that have a population between 160000 and 900000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the city table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the cities where the population is between 160000 and 900000.\n\n", "predict": "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"}, {"db_id": "world_1", "gold": "select name from city where population between 160000 and 900000", "question": "Return the names of cities that have a population between 160000 and 900000 .", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on cities with a population between 160000 and 900000. We need to select cities based on their population.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'city' table for this query.\n\n<3> SQL Generation: Use 'where' to filter cities based on their population range and select the names of those cities.\n\n", "predict": "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"}, {"db_id": "world_1", "gold": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "Count the number of countries for which Spanish is the predominantly spoken language.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the language column and counting the number of countries where Spanish is the predominantly spoken language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'country' table and the 'countrylanguage' table to filter countries where Spanish is the predominantly spoken language.\n\n<3> SQL Generation: Use 'where' to filter countries where the language is Spanish and is marked as the official language. Then, use 'count' to calculate the number of countries that meet this condition.\n\n", "predict": "SELECT COUNT(*) FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'T'"}, {"db_id": "world_1", "gold": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the language column, so we should apply the 'where' to column 'Language' and then return the corresponding country codes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'countrylanguage' has columns 'Language' and 'CountryCode', we only need table 'countrylanguage'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n", "predict": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND Percentage > 50"}, {"db_id": "orchestra", "gold": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"", "question": "Return the maximum and minimum shares for performances that do not have the type \"Live final\".", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter performances based on their type not being \"Live final\". Secondly, we need to select the maximum and minimum shares for the filtered performances.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'performance' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter performances based on their type not being \"Live final\", and then use 'select' to find the maximum and minimum shares for the filtered performances.\n\n", "predict": "SELECT MAX(share), MIN(share) FROM performance WHERE type != 'Live final'"}, {"db_id": "orchestra", "gold": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1", "question": "Show the names of conductors that have conducted more than one orchestras.", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on conductors who have conducted more than one orchestra. We need to select the names of these conductors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'conductor' table where the conductor ID appears more than once in the 'orchestra' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter conductors who have conducted more than one orchestra, and then select their names.\n\n", "predict": "SELECT Name FROM conductor WHERE Conductor_ID IN (SELECT Conductor_ID FROM orchestra GROUP BY Conductor_ID HAVING COUNT(Orchestra_ID) > 1)"}, {"db_id": "orchestra", "gold": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008", "question": "Please show the name of the conductor that has conducted orchestras founded after 2008.", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the orchestras that were founded after 2008. Secondly, we need to find the conductor who has conducted these orchestras.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Orchestra_ID from table 'orchestra' where Year_of_Founded is greater than 2008. In the second step, we need to select Name from table 'conductor' where Conductor_ID matches the Conductor_ID of the selected orchestras.\n\n<3> SQL Generation: Use 'where' to find the orchestras that were founded after 2008, and then use 'where' to find the conductor who has conducted these orchestras.\n\n", "predict": "SELECT T2.Name FROM orchestra AS T1 JOIN conductor AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE T1.Year_of_Founded > 2008"}, {"db_id": "orchestra", "gold": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008", "question": "What are the names of conductors who have conducted orchestras founded after the year 2008?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter orchestras based on their year of founding being after 2008. Secondly, we need to select the names of conductors who have conducted those filtered orchestras.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'conductor' and 'orchestra' tables, we need to consider those tables.\n\n<3> SQL Generation: Use 'where' to filter orchestras based on their year of founding being after 2008, and then select the names of conductors who have conducted those filtered orchestras.\n\n", "predict": "SELECT conductor.name FROM conductor JOIN orchestra ON conductor.Conductor_ID = orchestra.Conductor_ID WHERE orchestra.Year_of_Founded > 2008"}, {"db_id": "orchestra", "gold": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1", "question": "What are years of founding for orchestras that have had more than a single performance?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "<1> Decomposition: The query requires finding orchestras that have had more than a single performance. We need to select the years of founding for these orchestras.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'orchestra' table for this query.\n\n<3> SQL Generation: Use 'where' to filter orchestras that have had more than a single performance, and select the years of founding.\n\n", "predict": "SELECT Year_of_Founded FROM orchestra WHERE Orchestra_ID IN (SELECT Orchestra_ID FROM performance GROUP BY Orchestra_ID HAVING COUNT(*) > 1)"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"", "question": "Return the grade for the high schooler named Kyle.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the high schooler with the name \"Kyle\". Secondly, we need to retrieve the grade of that high schooler.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select grade from table 'Highschooler' where name = \"Kyle\".\n\n<3> SQL Generation: Use 'where' to find the high schooler with the name \"Kyle\", and then select the grade.\n\n", "predict": "SELECT grade FROM highschooler WHERE name = \"Kyle\""}, {"db_id": "network_1", "gold": "SELECT name FROM Highschooler WHERE grade  =  10", "question": "Show the names of all high schoolers in grade 10.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: We need to filter high schoolers based on their grade. Specifically, we need to find high schoolers in grade 10.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step and the foreign key relationships. We need the 'Highschooler' table and the 'grade' column.\n\n<3> SQL Generation: Use 'where' to filter high schoolers in grade 10, and then select their names.\n\n", "predict": "SELECT name FROM Highschooler WHERE grade = 10"}, {"db_id": "network_1", "gold": "SELECT name FROM Highschooler WHERE grade  =  10", "question": "What are the names of all high schoolers in grade 10?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding high schoolers who are in grade 10 and retrieving their names.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step and the foreign key relationships. We need to select the names from the 'Highschooler' table and filter out the high schoolers who are not in grade 10.\n\n<3> SQL Generation: We can use a 'where' clause to filter out the high schoolers who are not in grade 10 and select their names.\n\n", "predict": "SELECT name FROM Highschooler WHERE grade = 10"}, {"db_id": "network_1", "gold": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"", "question": "Show the ID of the high schooler named Kyle.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding the ID of the high schooler named Kyle.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the ID from the table 'Highschooler' where the name is 'Kyle'.\n\n<3> SQL Generation: Use 'where' to find the high schooler with the name 'Kyle' and select their ID.\n\n", "predict": "SELECT ID FROM Highschooler WHERE name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10", "question": "How many high schoolers are there in grade 9 or 10?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of high schoolers in grade 9 or 10.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the high schoolers from the 'Highschooler' table where the grade is 9 or 10.\n\n<3> SQL Generation: Use 'where' to filter the high schoolers in grade 9 or 10 and count them.\n\n", "predict": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10", "question": "Count the number of high schoolers in grades 9 or 10.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of high schoolers in grades 9 or 10. We need to filter out the high schoolers who are not in grades 9 or 10.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the high schoolers from the 'Highschooler' table and filter by the grade column.\n\n<3> SQL Generation: Use 'where' to filter out the high schoolers who are not in grades 9 or 10 and count the remaining high schoolers.\n\n", "predict": "SELECT count(*) FROM Highschooler WHERE grade IN (9, 10)"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4", "question": "Show me all grades that have at least 4 students.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: We need to find the grades that have at least 4 students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Highschooler' table.\n\n<3> SQL Generation: We can use the 'GROUP BY' clause to group the students by their grades, and then use the 'HAVING' clause to filter the grades that have at least 4 students.\n\n", "predict": "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4", "question": "Which grades have 4 or more high schoolers?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: We need to find the grades of high schoolers who have a count of 4 or more.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Highschooler' table.\n\n<3> SQL Generation: Use 'group by' to group the high schoolers by grade, and then use 'having' to filter the grades with a count of 4 or more.\n\n", "predict": "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3", "question": "Show the names of high schoolers who have at least 3 friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the high schoolers who have at least 3 friends. Secondly, we need to select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from the table 'Friend' and count the number of friends for each student. Then, we need to filter the high schoolers who have at least 3 friends and select their names from the table 'Highschooler'.\n\n<3> SQL Generation: Use 'group by' and 'count' to count the number of friends for each high schooler, and then use 'where' to filter the high schoolers who have at least 3 friends. Finally, select their names from the table 'Highschooler'.\n\n", "predict": "SELECT name FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend GROUP BY student_id HAVING COUNT(friend_id) >= 3)"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3", "question": "What are the names of high schoolers who have 3 or more friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on high schoolers who have 3 or more friends. We need to identify these high schoolers and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of high schoolers from the 'Highschooler' table who have 3 or more entries in the 'Friend' table with their ID as either the 'student_id' or 'friend_id'.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter high schoolers who have 3 or more friends, and then select their names.\n\n", "predict": "SELECT name FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend GROUP BY student_id HAVING COUNT(*) >= 3)"}, {"db_id": "network_1", "gold": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"", "question": "Show the names of all of the high schooler Kyle's friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the ID of the high schooler named Kyle. Secondly, we need to find the names of all the friends of Kyle.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ID from table 'Highschooler' where name = 'Kyle'. In the second step, we need to select the names from table 'Highschooler' where the IDs match the friend IDs of Kyle.\n\n<3> SQL Generation: Use 'where' to find the ID of the high schooler named Kyle, and then use 'join' to connect the friend IDs of Kyle with the IDs in the 'Highschooler' table to get the names of his friends.\n\n", "predict": "SELECT T2.name FROM Highschooler AS T1 JOIN Friend AS T3 ON T1.ID = T3.friend_id JOIN Highschooler AS T2 ON T2.ID = T3.student_id WHERE T1.name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"", "question": "Return the names of friends of the high school student Kyle.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires finding the names of friends of the high school student Kyle.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the 'Friend' table with the 'Highschooler' table on the 'friend_id' and 'ID' columns, respectively. Then, we can filter the rows where the 'name' column in the 'Highschooler' table matches 'Kyle'.\n\n<3> SQL Generation: We can use a 'join' to combine the 'Friend' and 'Highschooler' tables based on the foreign key relationships. Then, we can use a 'where' clause to filter the rows where the 'name' column in the 'Highschooler' table is 'Kyle'. Finally, we can select the 'name' column from the 'Highschooler' table.\n\n", "predict": "SELECT Highschooler.name FROM Friend JOIN Highschooler ON Friend.friend_id = Highschooler.ID WHERE Highschooler.name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id", "question": "Show name of all students who have some friends and also are liked by someone else.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who have friends. Secondly, we need to find the students who are liked by someone else. Finally, we need to retrieve the names of the students who satisfy both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Friend'. In the second step, we need to select student_id from table 'Likes' where liked_id is not equal to student_id. In the final step, we need to retrieve the names of the students from table 'Highschooler' who satisfy both conditions.\n\n<3> SQL Generation: Use 'where' to find the student_ids of the students who have friends. Then, use 'where' to find the student_ids of the students who are liked by someone else. Finally, use 'where' to retrieve the names of the students who satisfy both conditions.\n\n", "predict": "SELECT T1.name FROM Highschooler AS T1 JOIN Friend AS T2 ON T1.ID = T2.student_id JOIN Likes AS T3 ON T1.ID = T3.student_id WHERE T3.liked_id != T1.ID"}, {"db_id": "network_1", "gold": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id", "question": "What are the names of high schoolers who have likes, and how many likes does each have?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the high schoolers who have likes. Secondly, we need to count the number of likes each high schooler has. Finally, we need to select the names of the high schoolers and the corresponding number of likes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'Highschooler' table and count the number of likes from the 'Likes' table.\n\n<3> SQL Generation: Use 'inner join' to join the 'Highschooler' and 'Likes' tables on the 'ID' column. Then, use 'group by' and 'count' to count the number of likes for each high schooler. Finally, select the names of the high schoolers and the corresponding number of likes.\n\n", "predict": "SELECT H.name, COUNT(L.student_id) AS num_likes FROM Highschooler AS H INNER JOIN Likes AS L ON H.ID = L.student_id GROUP BY H.name"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "Show the names of students who have at least 2 likes.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who have at least 2 likes. Secondly, we need to select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Likes' and count the number of likes for each student. Then, we need to filter the students who have at least 2 likes and select their names from table 'Highschooler'.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of likes for each student and filter the students who have at least 2 likes. Then, use 'where' to select their names from table 'Highschooler'.\n\n", "predict": "SELECT name FROM Highschooler WHERE ID IN (SELECT student_id FROM Likes GROUP BY student_id HAVING COUNT(*) >= 2)"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "What are the names of students who have 2 or more likes?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on students who have 2 or more likes. We need to identify these students and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of students from the 'Highschooler' table who have 2 or more likes from the 'Likes' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter students who have 2 or more likes, join the 'Highschooler' and 'Likes' tables on the 'ID' column, and select the names of the students.\n\n", "predict": "SELECT name FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.student_id GROUP BY Highschooler.ID HAVING COUNT(Likes.liked_id) >= 2"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their grade being higher than 5. Secondly, we need to filter students based on having at least 2 friends. Finally, we need to select the names of the filtered students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'name' column from the 'Highschooler' table and filter based on the 'grade' column. We also need to join the 'Friend' table to count the number of friends for each student.\n\n<3> SQL Generation: Use 'where' to filter students based on their grade, and then use 'group by' and 'having' to filter students based on the number of friends. Finally, select the names of the filtered students.\n\n", "predict": "SELECT name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id GROUP BY Highschooler.ID HAVING Highschooler.grade > 5 AND COUNT(Friend.friend_id) >= 2"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on high schoolers with a grade over 5 and who have 2 or more friends. We need to select the names of these high schoolers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of high schoolers from the 'Highschooler' table who have a grade over 5 and have 2 or more friends from the 'Friend' table.\n\n<3> SQL Generation: Use 'where' to filter high schoolers with a grade over 5 and who have 2 or more friends, join the 'Highschooler' and 'Friend' tables on the 'ID' column, group by the high schooler's ID and name, and select the names of the high schoolers.\n\n", "predict": "SELECT H.name FROM Highschooler AS H JOIN Friend AS F ON H.ID = F.student_id WHERE H.grade > 5 GROUP BY H.ID, H.name HAVING COUNT(F.friend_id) >= 2"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"", "question": "Return the number of likes that the high schooler named Kyle has.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: We need to find the high schooler named Kyle and count the number of likes they have.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the number of likes from table 'Likes' where the student_id is the ID of the high schooler named Kyle.\n\n<3> SQL Generation: Use 'where' to filter the likes by the student_id of the high schooler named Kyle, and then use 'count' to calculate the number of likes.\n\n", "predict": "SELECT COUNT(*) FROM Likes WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle')"}, {"db_id": "network_1", "gold": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)", "question": "Find the average grade of all students who have some friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the students who have some friends. Secondly, we need to calculate the average grade of those students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Friend' and filter by friend_id. In the second step, we need to select grade from table 'Highschooler' and filter by ID.\n\n<3> SQL Generation: Use 'where' to filter students who have some friends, and then use 'avg' to calculate the average grade of those students.\n\n", "predict": "SELECT avg(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"}, {"db_id": "dog_kennels", "gold": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "question": "What is the average age of the dogs who have gone through any treatments?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the dogs who have gone through any treatments. Secondly, we need to calculate the average age of these dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dog_id from table 'Treatments'. In the second step, we need to select age from table 'Dogs' and filter by dog_id.\n\n<3> SQL Generation: Use 'where' to find the dogs who have gone through any treatments, and then use 'avg' to calculate the average age of these dogs.\n\n", "predict": "SELECT avg(age) FROM dogs WHERE dog_id IN (SELECT dog_id FROM treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "question": "Find the average age of the dogs who went through treatments.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: We need to find the dogs who went through treatments and calculate their average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dog_id from the 'Treatments' table and filter by dog_id. Then, we need to select age from the 'Dogs' table and filter by dog_id.\n\n<3> SQL Generation: Use 'where' to filter dogs who went through treatments, and then use 'avg' to calculate the average age of those dogs.\n\n", "predict": "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter dogs based on the amount spent by their owner for treatment. Secondly, we need to select the names of the filtered dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dog_id from table 'Treatments' where cost_of_treatment <= 1000. In the second step, we need to select name from table 'Dogs' where dog_id matches the dog_id found in the first step.\n\n<3> SQL Generation: Use 'where' to filter dogs based on the amount spent by their owner for treatment, and then select their names.\n\n", "predict": "SELECT D.name FROM Dogs AS D JOIN Treatments AS T ON D.dog_id = T.dog_id WHERE T.cost_of_treatment <= 1000"}, {"db_id": "dog_kennels", "gold": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id", "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding professionals who did not operate any treatment on dogs. Firstly, we need to identify all professionals who operated treatments on dogs. Secondly, we need to filter out professionals who operated treatments on dogs and return the details of the remaining professionals.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professional_id from table 'Treatments' and filter by dog_id. Then, we need to select professional_id, role_code, and email_address from table 'Professionals' and filter out the professionals who operated treatments on dogs.\n\n<3> SQL Generation: Use 'where' to filter professionals who operated treatments on dogs, and then use 'not in' to filter out those professionals and select their professional_id, role_code, and email_address.\n\n", "predict": "SELECT professional_id, role_code, email_address FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding professionals who have done at least two treatments. We need to select the professional's id, role, and first name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professional_id, role_code, and first_name from the 'Professionals' table and professional_id from the 'Treatments' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter professionals who have done at least two treatments, and then select their id, role, and first name.\n\n", "predict": "SELECT professional_id, role_code, first_name FROM Professionals WHERE professional_id IN (SELECT professional_id FROM Treatments GROUP BY professional_id HAVING COUNT(*) >= 2)"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average cost of treatments. Secondly, we need to find the professionals who have done treatments with a cost below the average. Finally, we need to select the first name and last name of these professionals.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name and last name from the 'Professionals' table and filter by the treatments with a cost below the average from the 'Treatments' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average cost of treatments from the 'Treatments' table. Then, join the 'Treatments' and 'Professionals' tables on the 'professional_id' column and filter by treatments with a cost below the average. Finally, select the first name and last name of the professionals.\n\n", "predict": "SELECT T1.first_name ,  T1.last_name FROM professionals AS T1 JOIN treatments AS T2 ON T2.professional_id  =  T1.professional_id WHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average cost of treatments. Secondly, we need to find the treatments that cost less than the average. Lastly, we need to identify the professionals who have operated these treatments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Professionals' table to get the first and last names of the professionals, and we need the 'Treatments' table to filter treatments based on their cost.\n\n<3> SQL Generation: Use 'select avg(cost_of_treatment)' to calculate the average cost of treatments. Then, use 'where' to filter treatments with a cost less than the average. Finally, select the first and last names of the professionals who operated these treatments.\n\n", "predict": "SELECT T1.first_name, T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id WHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding the dogs of the rarest breed and their treatment dates. Firstly, we need to identify the rarest breed. Secondly, we need to select the names of the dogs belonging to that breed. Lastly, we need to retrieve the treatment dates for those dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the breed_code from the 'Breeds' table and filter the dogs based on that breed in the 'Dogs' table. Then, we need to select the names of the dogs from the 'Dogs' table and retrieve the treatment dates from the 'Treatments' table.\n\n<3> SQL Generation: Use 'where' to filter the dogs based on the rarest breed, select the names of those dogs, and join with the 'Treatments' table to retrieve the treatment dates.\n\n", "predict": "SELECT D.name, T.date_of_treatment FROM Dogs AS D JOIN Treatments AS T ON D.dog_id = T.dog_id WHERE D.breed_code = (SELECT breed_code FROM Breeds GROUP BY breed_code HAVING COUNT(*) = (SELECT MIN(count) FROM (SELECT COUNT(*) AS count FROM Dogs GROUP BY breed_code) AS subquery))"}, {"db_id": "dog_kennels", "gold": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "question": "Which dogs are of the rarest breed? Show their names and treatment dates.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the rarest breed of dogs. Secondly, we need to find the dogs that belong to that breed. Finally, we need to select the names and treatment dates of those dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the breed_code from the 'Dogs' table and filter by the rarest breed from the 'Breeds' table. Then, we need to join the 'Dogs' and 'Treatments' tables on the 'dog_id' column and select the names and treatment dates.\n\n<3> SQL Generation: Use 'group by' and 'order by' to find the rarest breed from the 'Dogs' table. Then, join the 'Dogs' and 'Treatments' tables on the 'dog_id' column and filter by the rarest breed. Finally, select the names and treatment dates of the dogs.\n\n", "predict": "SELECT T1.name, T5.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T5 ON T1.dog_id = T5.dog_id WHERE T1.breed_code = (SELECT breed_code FROM Breeds GROUP BY breed_code ORDER BY COUNT(*) ASC LIMIT 1)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'", "question": "Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the owners who live in Virginia. Secondly, we need to select the dogs owned by those owners and list the owner's first name and the dog's name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first_name from table 'Owners' where the state is Virginia. Then, we need to select the dog's name from table 'Dogs' based on the owner_id.\n\n<3> SQL Generation: Use 'where' to find the owners who live in Virginia, and then use 'join' to select the dog's name based on the owner_id. Finally, select the owner's first name and the dog's name.\n\n", "predict": "SELECT Owners.first_name, Dogs.name FROM Owners JOIN Dogs ON Owners.owner_id = Dogs.owner_id WHERE Owners.state = 'Virginia'"}, {"db_id": "dog_kennels", "gold": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'", "question": "Find the first names of owners living in Virginia and the names of dogs they own.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter owners based on their state, specifically Virginia. Secondly, we need to find the names of the dogs owned by those owners.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first names from the 'Owners' table and filter by the state 'Virginia'. Then, we need to join the 'Owners' and 'Dogs' tables on the 'owner_id' column and retrieve the names of the dogs.\n\n<3> SQL Generation: Use 'where' to filter owners based on the state 'Virginia', and then join the 'Owners' and 'Dogs' tables on the 'owner_id' column. Finally, select the first names of the owners and the names of the dogs.\n\n", "predict": "SELECT T1.first_name, T3.name FROM Owners AS T1 JOIN Dogs AS T3 ON T1.owner_id = T3.owner_id WHERE T1.state = 'Virginia'"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the dogs that have gone through a treatment. Secondly, we need to retrieve the arriving date and departing date of those dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the dog_id from table 'Treatments' to find the dogs that have gone through a treatment. Then, we need to retrieve the arriving date and departing date from table 'Dogs'.\n\n<3> SQL Generation: Use 'where' to find the dogs that have gone through a treatment, and then select the arriving date and departing date.\n\n", "predict": "SELECT date_arrived, date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "question": "Find the arriving date and the departing date of the dogs that received a treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding the arriving date and departing date of the dogs that received a treatment. Firstly, we need to filter the dogs that received a treatment. Secondly, we need to select the arriving date and departing date of those dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dog_id from the 'treatments' table. In the second step, we need to select date_arrived and date_departed from the 'dogs' table.\n\n<3> SQL Generation: Use 'where' to filter the dogs that received a treatment, and then select the arriving date and departing date from the 'dogs' table.\n\n", "predict": "SELECT date_arrived, date_departed FROM dogs WHERE dog_id IN (SELECT dog_id FROM treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "question": "List the last name of the owner owning the youngest dog.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: We need to find the youngest dog and then identify its owner.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Dogs' table to find the youngest dog and the 'Owners' table to get the last name of its owner.\n\n<3> SQL Generation: Use 'order by' to sort the dogs by age in ascending order, select the first row (which represents the youngest dog), and then join the 'Owners' table to get the last name of its owner.\n\n", "predict": "SELECT last_name FROM Owners JOIN Dogs ON Owners.owner_id = Dogs.owner_id ORDER BY age ASC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT dog_id) FROM Treatments", "question": "Count the number of dogs that went through a treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires counting the number of dogs that went through a treatment. We need to select dogs that have records in the 'Treatments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dog_id from the 'Treatments' table.\n\n<3> SQL Generation: Use 'count' to count the number of distinct dog_ids in the 'Treatments' table.\n\n", "predict": "SELECT count(DISTINCT dog_id) FROM Treatments"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT professional_id) FROM Treatments", "question": "How many professionals have performed any treatment to dogs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the professionals who have performed any treatment to dogs. Secondly, we need to count the number of professionals found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professionals from the 'Professionals' table and filter out those who have performed treatments in the 'Treatments' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Professionals' and 'Treatments' tables on the 'professional_id' column. Then, we can filter out the rows where the 'treatment_id' column is not null, indicating that the professional has performed treatments. Finally, we can count the number of professionals who meet this condition.\n\n", "predict": "SELECT count(*) FROM professionals WHERE professional_id IN (SELECT professional_id FROM treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT professional_id) FROM Treatments", "question": "Find the number of professionals who have ever treated dogs.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: We need to find the professionals who have ever treated dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the distinct professional IDs from the 'Treatments' table.\n\n<3> SQL Generation: Use 'select distinct' to retrieve the unique professional IDs from the 'Treatments' table, and then count the number of professionals.\n\n", "predict": "SELECT COUNT(DISTINCT professional_id) FROM Treatments"}, {"db_id": "dog_kennels", "gold": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'", "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find professionals who live in a city containing the substring 'West'. Secondly, we need to select their role, street, city, and state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the role, street, city, and state from the 'Professionals' table.\n\n<3> SQL Generation: Use 'where' to find professionals who live in a city containing the substring 'West', and then select their role, street, city, and state.\n\n", "predict": "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%'"}, {"db_id": "dog_kennels", "gold": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'", "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the city that contains the substring 'West'. Secondly, we need to find the professionals who are living in that city and retrieve their role, street, city, and state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we don't need to use any tables. In the second step, we need to filter the city from table 'Professionals' and retrieve the corresponding role, street, city, and state.\n\n<3> SQL Generation: Use 'where' to find the professionals who are living in a city that contains the substring 'West' and select their role, street, city, and state.\n\n", "predict": "SELECT role_code, street, city, state FROM professionals WHERE city LIKE '%West%'"}, {"db_id": "dog_kennels", "gold": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'", "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to find the owners who live in a state with a name containing the substring 'North'. Secondly, we need to select their first name, last name, and email.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first_name, last_name, and email_address from the 'Owners' table.\n\n<3> SQL Generation: Use 'where' to find the owners who live in a state with a name containing the substring 'North', and then select their first name, last name, and email.\n\n", "predict": "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%'"}, {"db_id": "dog_kennels", "gold": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'", "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter owners based on the state name containing the substring 'North'. Secondly, we need to select the first name, last name, and email of the selected owners.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the first name, last name, and email of the owners, we only need the 'Owners' table.\n\n<3> SQL Generation: Use 'where' to filter owners based on the state name containing the substring 'North', and then select the first name, last name, and email columns.\n\n", "predict": "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE \"%North%\""}, {"db_id": "dog_kennels", "gold": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )", "question": "How many dogs have an age below the average?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of dogs. Secondly, we need to count the number of dogs with an age below the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'age' column from the 'Dogs' table, we only need the 'Dogs' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of dogs, and then use 'where' to filter dogs with an age below the average.\n\n", "predict": "SELECT count(*) FROM Dogs WHERE age < (SELECT avg(age) FROM Dogs)"}, {"db_id": "dog_kennels", "gold": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )", "question": "Count the number of dogs of an age below the average.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all dogs. Secondly, we need to count the number of dogs with an age below the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Dogs' table for this query.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of all dogs, and then use 'where' to filter the dogs with an age below the average. Finally, use 'count' to count the number of dogs that meet this condition.\n\n", "predict": "SELECT COUNT(*) FROM Dogs WHERE age < (SELECT AVG(age) FROM Dogs)"}, {"db_id": "dog_kennels", "gold": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments )", "question": "How many dogs have not gone through any treatment?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding dogs that have not gone through any treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dog_id from table 'Dogs' and filter by dog_id in table 'Treatments'.\n\n<3> SQL Generation: Use 'where' to filter dogs that have not gone through any treatment and count them.\n\n", "predict": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments );"}, {"db_id": "dog_kennels", "gold": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )", "question": "How many owners temporarily do not have any dogs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: The query requires finding owners who temporarily do not have any dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select owner_id from table 'Owners' and filter by owner_id in table 'Dogs'.\n\n<3> SQL Generation: Use 'where' to filter owners who temporarily do not have any dogs and count them.\n\n", "predict": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs );"}, {"db_id": "dog_kennels", "gold": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1", "question": "List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter dogs based on whether they have been abandoned or not. Secondly, we need to select the dog name, age, and weight of the filtered dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name, age, and weight from table 'Dogs' and filter based on the abandoned_yn column.\n\n<3> SQL Generation: Use 'where' to filter dogs based on whether they have been abandoned or not, and then select the dog name, age, and weight of the filtered dogs.\n\n", "predict": "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = 1"}, {"db_id": "dog_kennels", "gold": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1", "question": "What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "<1> Decomposition: Firstly, we need to filter dogs based on the 'abandoned_yn' column being 1 (indicating yes). Secondly, we need to select the dog name, age, and weight for the filtered dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'Dogs' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter dogs based on the 'abandoned_yn' column being 1, and then select the dog name, age, and weight for the filtered dogs.\n\n", "predict": "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = 1"}, {"db_id": "singer", "gold": "SELECT Name FROM singer WHERE Citizenship != \"France\"", "question": "List the name of singers whose citizenship is not \"France\".", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the citizenship of singers, so we should apply the 'where' clause to the column 'Citizenship' and then return the names of the selected singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the singers, we only need the 'singer' table.\n\n<3> SQL Generation: Directly write the SQL query using 'where'.\n\n", "predict": "SELECT Name FROM singer WHERE Citizenship != \"France\""}, {"db_id": "singer", "gold": "SELECT Name FROM singer WHERE Citizenship != \"France\"", "question": "What are the names of the singers who are not French citizens?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on the citizenship of singers. We need to select the names of singers who are not French citizens.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'singer' table.\n\n<3> SQL Generation: Use 'where' to filter singers who are not French citizens and select their names.\n\n", "predict": "SELECT Name FROM singer WHERE Citizenship != 'French'"}, {"db_id": "singer", "gold": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000", "question": "Show distinct names of singers that have songs with sales more than 300000.", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on songs with sales more than 300000. Firstly, we need to identify the songs with sales more than 300000. Secondly, we need to find the distinct names of singers who have these songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Singer_ID from table 'song' where Sales > 300000. In the second step, we need to select distinct Name from table 'singer' where Singer_ID is in the selected Singer_IDs.\n\n<3> SQL Generation: Use 'where' to filter songs with sales more than 300000, and then use 'where' and 'distinct' to select the distinct names of singers who have these songs.\n\n", "predict": "SELECT DISTINCT Name FROM singer WHERE Singer_ID IN (SELECT Singer_ID FROM song WHERE Sales  >  300000)"}, {"db_id": "singer", "gold": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000", "question": "what are the different names of the singers that have sales more than 300000?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "<1> Decomposition: The query requires finding singers with sales more than 300000. We need to select the names of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need both the 'singer' and 'song' tables, and we need to link them using the 'Singer_ID' column.\n\n<3> SQL Generation: Use 'where' to filter songs with sales more than 300000, and then select the distinct names of the singers.\n\n", "predict": "SELECT DISTINCT Name FROM singer JOIN song ON singer.Singer_ID = song.Singer_ID WHERE Sales > 300000"}, {"db_id": "singer", "gold": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1", "question": "Show the names of singers that have more than one song.", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "<1> Decomposition: The query requires filtering on singers that have more than one song. We need to select the names of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'singer' table and the 'name' column.\n\n<3> SQL Generation: Use 'where' and 'group by' to filter singers that have more than one song and select their names.\n\n", "predict": "SELECT name FROM singer JOIN song ON singer.singer_id = song.singer_id GROUP BY singer.singer_id HAVING COUNT(song.song_id) > 1"}]