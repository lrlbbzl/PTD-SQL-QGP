[{"db_id": "concert_singer", "gold": "SELECT count(*) FROM singer", "question": "How many singers do we have?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we want to count the number of singers, we only need the 'singer' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'singer' table.\n\n", "predict": "SELECT count(*) FROM singer"}, {"db_id": "concert_singer", "gold": "SELECT count(*) FROM singer", "question": "What is the total number of singers?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the total number of singers, so we can directly count the number of rows in the 'singer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need the 'singer' table to count the total number of singers, we only need to use the 'singer' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'singer' table.\n\n", "predict": "SELECT COUNT(*) FROM singer"}, {"db_id": "pets_1", "gold": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1", "question": "Find the weight of the youngest dog.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the pets based on their type, selecting only dogs. Secondly, we need to find the youngest dog based on their age. Finally, we need to retrieve the weight of the youngest dog.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Pet', 'Pets'].\n\n<3> SQL Generation: We join the 'Has_Pet' and 'Pets' tables on the 'PetID' column. Then, we filter the rows where 'PetType' is 'dog' and find the minimum 'pet_age'. Finally, we retrieve the 'weight' of the row that matches the minimum 'pet_age'.\n\n", "predict": "SELECT weight FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.PetType = 'dog' AND T2.pet_age = (SELECT MIN(pet_age) FROM Pets WHERE PetType = 'dog')"}, {"db_id": "pets_1", "gold": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1", "question": "How much does the youngest dog weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to retrieve its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Pet', 'Pets'].\n\n<3> SQL Generation: We join the 'Has_Pet' and 'Pets' tables on the 'PetID' column. Then, we filter the rows where 'PetType' is 'dog' and find the minimum value of 'pet_age'. Finally, we retrieve the 'weight' column for the row that matches the youngest dog.\n\n", "predict": "SELECT weight FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.PetType = 'dog' AND T2.pet_age = (SELECT MIN(pet_age) FROM Pets WHERE PetType = 'dog')"}, {"db_id": "pets_1", "gold": "SELECT count(DISTINCT pettype) FROM pets", "question": "Find the number of distinct type of pets.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to find the distinct types of pets, so we can decompose the query into two subproblems: 1. selecting the 'PetType' column from the 'Pets' table; 2. counting the distinct types of pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use the 'Pets' table. To complete the second subproblem, we don't need any additional tables.\n\n<3> SQL Generation: We can use the 'SELECT DISTINCT' statement to select the distinct types of pets from the 'PetType' column in the 'Pets' table. Then, we can use the 'COUNT' function to count the number of distinct types.\n\n", "predict": "SELECT COUNT(DISTINCT PetType) FROM Pets"}, {"db_id": "pets_1", "gold": "SELECT count(DISTINCT pettype) FROM pets", "question": "How many different types of pet are there?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of different types of pets, so we can achieve this by selecting distinct values from the 'PetType' column in the 'Pets' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to count the number of different pet types, we only need to use the 'Pets' table.\n\n<3> SQL Generation: We can use the 'COUNT(DISTINCT)' function to count the number of distinct pet types in the 'PetType' column of the 'Pets' table.\n\n", "predict": "SELECT COUNT(DISTINCT PetType) FROM Pets"}, {"db_id": "pets_1", "gold": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1", "question": "What type of pet is the youngest animal, and how much does it weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest animal by selecting the minimum value of 'pet_age' from table 'Pets'. Secondly, we need to identify the type of pet and its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Pets'].\n\n<3> SQL Generation: Use 'min' operation to select the minimum value of 'pet_age' from table 'Pets'. Then, use 'where' to filter the row where 'pet_age' is equal to the minimum value. Finally, select the 'PetType' and 'weight' columns.\n\n", "predict": "SELECT PetType, weight FROM Pets WHERE pet_age = (SELECT MIN(pet_age) FROM Pets)"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CONTINENTS;", "question": "How many continents are there?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of continents, we only need to use the 'continents' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'continents' table.\n\n", "predict": "SELECT count(*) FROM continents"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CONTINENTS;", "question": "What is the number of continents?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of continents, we only need to use the 'continents' table.\n\n<2> Operation: To find the number of continents, we can simply count the number of rows in the 'continents' table.\n\n<3> SQL Generation: Use the 'count' function to count the number of rows in the 'continents' table.\n\n", "predict": "SELECT count(*) FROM continents"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM COUNTRIES;", "question": "How many countries are listed?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of countries listed, we only need to use the 'countries' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'countries' table.\n\n", "predict": "SELECT count(*) FROM countries"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM COUNTRIES;", "question": "How many countries exist?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of countries, we only need to use the 'countries' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'countries' table.\n\n", "predict": "SELECT count(*) FROM countries"}, {"db_id": "car_1", "gold": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "question": "What is the maker of the car produced in the earliest year and what year was it?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the car produced in the earliest year. Secondly, we need to identify the maker of that car and the year it was produced.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['cars_data', 'car_names', 'model_list', 'car_makers'].\n\n<3> SQL Generation: We need to join the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables on the appropriate columns. Then, we filter the rows to find the car with the earliest year. Finally, we select the maker and the year of that car.\n\n", "predict": "\nSELECT car_makers.Maker, cars_data.Year \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nORDER BY cars_data.Year ASC \nLIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the car_id of the car with the model 'amc hornet sportabout (sw)'. Then, we can use this car_id to retrieve the acceleration value from the 'Accelerate' column in the 'cars_data' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['car_makers', 'model_list', 'car_names', 'cars_data'].\n\n<3> SQL Generation: We need to join the 'car_makers', 'model_list', 'car_names', and 'cars_data' tables on their respective foreign key columns. Then, we filter the rows where the model is 'amc hornet sportabout (sw)'. Finally, we select the 'Accelerate' column to retrieve the acceleration value.\n\n", "predict": "SELECT T4.Accelerate FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker JOIN car_names AS T3 ON T2.Model = T3.Model JOIN cars_data AS T4 ON T3.MakeId = T4.Id WHERE T3.Model = 'amc hornet sportabout (sw)'"}, {"db_id": "car_1", "gold": "SELECT Maker ,  Model FROM MODEL_LIST;", "question": "What are all the makers and models?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get all the makers and models, we need to use tables ['car_makers', 'model_list', 'car_names'].\n\n<2> SQL Generation: We need to join the 'car_makers', 'model_list', and 'car_names' tables on the appropriate columns. Then, we select the 'Maker' and 'Model' columns from the joined tables.\n\n", "predict": "SELECT car_makers.Maker, model_list.Model FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model"}, {"db_id": "car_1", "gold": "SELECT Maker ,  Model FROM MODEL_LIST;", "question": "What are the makers and models?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the makers and models, we need to use tables ['car_makers', 'model_list', 'car_names'].\n\n<2> SQL Generation: We need to join the 'car_makers', 'model_list', and 'car_names' tables on the appropriate columns. Then, we select the 'Maker' and 'Model' columns from the joined tables.\n\n", "predict": "SELECT car_makers.Maker, model_list.Model FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the maximum miles per gallon (MPG) value from the 'cars_data' table. Secondly, we need to identify the model that corresponds to this maximum MPG value.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['cars_data', 'car_names', 'model_list'].\n\n<3> SQL Generation: We can join the 'cars_data', 'car_names', and 'model_list' tables on the appropriate columns. Then, we can select the model that has the maximum MPG value using the 'MAX' function.\n\n", "predict": "\nSELECT T3.Model\nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nJOIN model_list AS T3 ON T2.Model = T3.Model\nWHERE T1.MPG = (SELECT MAX(MPG) FROM cars_data)"}, {"db_id": "car_1", "gold": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "question": "What is the car model with the highest mpg ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the car model with the highest MPG (miles per gallon).\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['car_makers', 'car_names', 'cars_data'].\n\n<3> SQL Generation: We can join the 'car_makers', 'car_names', and 'cars_data' tables on the appropriate columns. Then, we can select the car model with the highest MPG using the 'MAX' function.\n\n", "predict": "SELECT T2.Model FROM car_makers AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.MPG = (SELECT MAX(MPG) FROM cars_data)"}, {"db_id": "car_1", "gold": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "question": "What model has the most different versions?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of versions for each model. Secondly, we need to find the model with the highest count of versions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['car_makers', 'model_list', 'car_names'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'Model' in table 'car_names' to count the number of versions for each model. Then, we need to find the model with the highest count.\n\n<4> SQL Generation: We use 'GROUP BY' and 'COUNT' to count the number of versions for each model in table 'car_names'. Then, we use 'ORDER BY' and 'DESC' to sort the count in descending order. Finally, we use 'LIMIT' to select the model with the highest count.\n\n", "predict": "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;", "question": "how many cars were produced in 1980?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the cars based on the year they were produced. Secondly, we need to count the number of cars that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['cars_data'].\n\n<3> SQL Generation: We filter the rows in the 'cars_data' table where the 'Year' column is equal to 1980. Finally, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Year = 1980"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;", "question": "In 1980, how many cars were made?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: In this step, we need to filter the cars based on the year they were made, specifically in 1980. Then, we need to count the number of cars that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['cars_data'].\n\n<3> SQL Generation: We filter the rows in the 'cars_data' table where the 'Year' column is equal to 1980. Then, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Year = 1980"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';", "question": "How many car models were produced by the maker with full name American Motor Company?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the maker with the full name \"American Motor Company\". Secondly, we need to count the number of car models produced by this maker.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['car_makers', 'model_list'].\n\n<3> SQL Generation: Use 'where' to filter the maker with the full name \"American Motor Company\" and count the number of car models.\n\n", "predict": "SELECT count(*) FROM model_list JOIN car_makers ON model_list.Maker = car_makers.Id WHERE car_makers.FullName = 'American Motor Company'"}, {"db_id": "car_1", "gold": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;", "question": "What is the horsepower of the car with the greatest accelerate?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the car with the greatest acceleration. Secondly, we need to retrieve the horsepower of that car.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the car with the greatest acceleration from table 'cars_data'. In the second step, we need to retrieve the horsepower of that car from table 'cars_data'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the car with the greatest acceleration, and then retrieve the horsepower of that car.\n\n", "predict": "SELECT Horsepower FROM cars_data ORDER BY Accelerate DESC LIMIT 1"}, {"db_id": "flight_2", "gold": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"", "question": "Which country does Airline \"JetBlue Airways\" belong to?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to find the country of the airline, we need to use the 'airlines' table.\n\n<2> SQL Generation: We need to select the 'Country' column from the 'airlines' table where the 'Airline' column is equal to \"JetBlue Airways\".\n\n", "predict": "SELECT Country FROM airlines WHERE Airline = \"JetBlue Airways\""}, {"db_id": "flight_2", "gold": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"", "question": "What country is Jetblue Airways affiliated with?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the airline with the name 'Jetblue Airways'. Secondly, we need to determine the country that the airline is affiliated with.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'airlines' table to find the airline with the name 'Jetblue Airways'.\n\n<3> SQL Generation: We can use a simple 'SELECT' statement to retrieve the country column from the 'airlines' table, filtering by the airline name.\n\n", "predict": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways'"}, {"db_id": "flight_2", "gold": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"", "question": "What is the abbreviation of Airline \"JetBlue Airways\"?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the abbreviation of Airline \"JetBlue Airways\", we need to use the table 'airlines'.\n\n<2> SQL Generation: We need to select the 'Abbreviation' column from the 'airlines' table where the 'Airline' column is equal to \"JetBlue Airways\".\n\n", "predict": "SELECT Abbreviation FROM airlines WHERE Airline = \"JetBlue Airways\""}, {"db_id": "flight_2", "gold": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"", "question": "List all airline names and their abbreviations in \"USA\".", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['airlines', 'airports'].\n\n<2> SQL Generation: We need to select the 'Airline' and 'Abbreviation' columns from the 'airlines' table. Then, we need to filter the rows where the 'Country' is 'USA'.\n\n", "predict": "SELECT Airline, Abbreviation FROM airlines WHERE Country = 'USA'"}, {"db_id": "flight_2", "gold": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"", "question": "What are the airline names and abbreviations for airlines in the USA?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter airlines based on their country, selecting only those in the USA. Secondly, we need to select the airline names and abbreviations for the filtered airlines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'airlines' table for this query.\n\n<3> SQL Generation: We filter the rows in the 'airlines' table where the country is 'USA'. Then, we select the airline names and abbreviations from the filtered rows.\n\n", "predict": "SELECT Airline, Abbreviation FROM airlines WHERE Country = 'USA'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES", "question": "How many airlines do we have?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of airlines, we only need to use the 'airlines' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'airlines' table.\n\n", "predict": "SELECT count(*) FROM airlines"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRLINES", "question": "What is the total number of airlines?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the total number of airlines, we only need to use the 'airlines' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'airlines' table.\n\n", "predict": "SELECT count(*) FROM airlines"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRPORTS", "question": "How many airports do we have?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of airports, so we can directly count the number of rows in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query. We only need to use the 'airports' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'airports' table.\n\n", "predict": "SELECT count(*) FROM airports"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM AIRPORTS", "question": "Return the number of  airports.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query simply asks for the number of airports, so no further decomposition is needed.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'airports' table.\n\n<3> SQL Generation: Since we only need to count the number of airports, we can use the 'count' function on the primary key column of the 'airports' table.\n\n", "predict": "SELECT count(*) FROM airports"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS", "question": "How many flights do we have?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of flights, so we don't need to perform any filtering or calculations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'flights' table.\n\n<3> SQL Generation: Since we don't need to perform any filtering or calculations, we can simply use the 'count' function to count the number of rows in the 'flights' table.\n\n", "predict": "SELECT count(*) FROM flights"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS", "question": "Return the number of flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query simply asks for the number of flights, so no further decomposition is needed.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'flights' table for this query.\n\n<3> SQL Generation: Since we only need to count the number of flights, we can use the 'count' function on any column in the 'flights' table. We can use the '*' wildcard to count all rows in the table.\n\n", "predict": "SELECT count(*) FROM flights"}, {"db_id": "flight_2", "gold": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"", "question": "Which city and country is the Alton airport at?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'airports' table to find the city and country of the Alton airport.\n\n<2> SQL Generation: We can use a simple 'SELECT' statement to retrieve the city and country columns from the 'airports' table, filtering by the airport name being 'Alton'.\n\n", "predict": "SELECT City, Country FROM airports WHERE AirportName = 'Alton'"}, {"db_id": "flight_2", "gold": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"", "question": "What is the airport name for airport 'AKO'?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'airports' table to find the airport name.\n\n<2> SQL Generation: We can use a simple 'SELECT' statement to retrieve the airport name from the 'airports' table based on the given airport code.\n\n", "predict": "SELECT AirportName FROM airports WHERE AirportCode = 'AKO'"}, {"db_id": "flight_2", "gold": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"", "question": "Give the number of Jetblue Airways flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to filter flights based on the airline 'Jetblue Airways' and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'flights' table.\n\n<3> SQL Generation: We filter the rows where the airline is 'Jetblue Airways' and count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM flights WHERE Airline = 'Jetblue Airways'"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT count(*) FROM employee", "question": "How many employees are there?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the total number of employees, we only need to use the 'employee' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'employee' table.\n\n", "predict": "SELECT count(*) FROM employee"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT count(*) FROM employee", "question": "Count the number of employees", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires counting the number of employees, so we can directly count the number of rows in the 'employee' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires counting the number of employees, we only need to use the 'employee' table.\n\n<3> SQL Generation: Use the 'count' function to count the number of rows in the 'employee' table.\n\n", "predict": "SELECT count(*) FROM employee"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1", "question": "Find the name of the employee who got the highest one time bonus.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the highest one-time bonus awarded to an employee. Secondly, we need to retrieve the name of the employee who received that bonus.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['employee', 'evaluation'].\n\n<3> SQL Generation: We can use the 'MAX' function to find the highest one-time bonus in the 'evaluation' table. Then, we can join the 'employee' table with the 'evaluation' table on the 'Employee_ID' column and filter the rows where the bonus is equal to the highest one-time bonus. Finally, we select the name of the employee.\n\n", "predict": "SELECT employee.Name FROM employee JOIN evaluation ON employee.Employee_ID = evaluation.Employee_ID WHERE evaluation.Bonus = (SELECT MAX(Bonus) FROM evaluation)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1", "question": "Which employee received the biggest bonus? Give me the employee name.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the employee with the biggest bonus. Secondly, we need to retrieve the name of that employee.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['employee', 'evaluation'].\n\n<3> SQL Generation: We can use the 'MAX' function to find the maximum bonus amount in the 'evaluation' table. Then, we can join the 'employee' table with the 'evaluation' table on the 'Employee_ID' column and filter the rows where the bonus is equal to the maximum bonus. Finally, we select the name of the employee.\n\n", "predict": "SELECT employee.Name FROM employee JOIN evaluation ON employee.Employee_ID = evaluation.Employee_ID WHERE evaluation.Bonus = (SELECT MAX(Bonus) FROM evaluation)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1", "question": "What is the name of the shop that is hiring the largest number of employees?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the shop that is hiring the largest number of employees. Secondly, we need to retrieve the name of that shop.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['shop', 'hiring'] to find the shop that is hiring the largest number of employees.\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'Shop_ID' in the 'hiring' table and count the number of employees for each shop. Then, we can sort the result in descending order and retrieve the shop with the highest count.\n\n<4> SQL Generation: Use 'order by' and 'desc' to select the shop with the highest count, and then retrieve its name from the 'shop' table.\n\n", "predict": "SELECT Name FROM shop WHERE Shop_ID = (SELECT Shop_ID FROM hiring GROUP BY Shop_ID ORDER BY COUNT(*) DESC LIMIT 1)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT sum(bonus) FROM evaluation", "question": "What is total bonus given in all evaluations?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the total bonus given in all evaluations, so we need to sum up the 'Bonus' column in the 'evaluation' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'evaluation' table for this query.\n\n<3> SQL Generation: We can use the 'SUM' function to calculate the total bonus from the 'Bonus' column in the 'evaluation' table.\n\n", "predict": "SELECT SUM(Bonus) FROM evaluation"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT sum(bonus) FROM evaluation", "question": "Find the total amount of bonus given in all the evaluations.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the total amount of bonus given in all the evaluations. This can be achieved by summing up the 'Bonus' column in the 'evaluation' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'evaluation' table for this query.\n\n<3> SQL Generation: We can use the 'SUM' function to calculate the total amount of bonus in the 'Bonus' column of the 'evaluation' table.\n\n", "predict": "SELECT SUM(Bonus) FROM evaluation"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT * FROM hiring", "question": "Give me all the information about hiring.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve all the information about hiring, we need to use tables ['employee', 'evaluation', 'hiring', 'shop'].\n\n<2> SQL Generation: We can join the 'employee', 'evaluation', 'hiring', and 'shop' tables on the appropriate foreign key columns to retrieve all the information about hiring.\n\n", "predict": "SELECT * FROM employee AS T1 JOIN evaluation AS T2 ON T1.Employee_ID = T2.Employee_ID JOIN hiring AS T3 ON T1.Employee_ID = T3.Employee_ID JOIN shop AS T4 ON T3.Shop_ID = T4.Shop_ID WHERE T3.Start_from IS NOT NULL"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT * FROM hiring", "question": "What is all the information about hiring?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve all the information about hiring, we need to use tables ['employee', 'evaluation', 'hiring', 'shop'].\n\n<2> SQL Generation: We can join the 'employee', 'evaluation', 'hiring', and 'shop' tables on the appropriate foreign key columns to retrieve all the information about hiring.\n\n", "predict": "\nSELECT * FROM employee AS T1 \nJOIN evaluation AS T2 ON T1.Employee_ID = T2.Employee_ID \nJOIN hiring AS T3 ON T1.Employee_ID = T3.Employee_ID \nJOIN shop AS T4 ON T3.Shop_ID = T4.Shop_ID"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT count(DISTINCT LOCATION) FROM shop", "question": "How many different store locations are there?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of different store locations, we need to use the 'shop' table.\n\n<2> SQL Generation: We need to count the distinct values in the 'Location' column of the 'shop' table.\n\n", "predict": "SELECT COUNT(DISTINCT Location) FROM shop"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT count(DISTINCT LOCATION) FROM shop", "question": "Count the number of distinct store locations.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query requires counting the number of distinct store locations, we need to use the 'shop' table.\n\n<2> SQL Generation: We can use the 'COUNT' function along with the 'DISTINCT' keyword to count the number of distinct store locations in the 'shop' table.\n\n", "predict": "SELECT COUNT(DISTINCT Location) FROM shop"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Documents", "question": "How many documents do we have?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of documents, we only need to use the 'Documents' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'Documents' table.\n\n", "predict": "SELECT count(*) FROM Documents"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Documents", "question": "Count the number of documents.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to count the number of documents, we only need to use the 'Documents' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of documents in the 'Documents' table.\n\n", "predict": "SELECT count(*) FROM Documents"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id ,  document_name ,  document_description FROM Documents", "question": "List document IDs, document names, and document descriptions for all documents.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the document IDs, document names, and document descriptions, we need to use tables ['Documents'].\n\n<2> SQL Generation: We can simply select the 'Document_ID', 'Document_Name', and 'Document_Description' columns from the 'Documents' table.\n\n", "predict": "SELECT Document_ID, Document_Name, Document_Description FROM Documents"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id ,  document_name ,  document_description FROM Documents", "question": "What are the ids, names, and descriptions for all documents?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the ids, names, and descriptions for all documents, we need to use tables ['Documents'].\n\n<2> SQL Generation: We can simply select the 'Document_ID', 'Document_Name', and 'Document_Description' columns from the 'Documents' table.\n\n", "predict": "SELECT Document_ID, Document_Name, Document_Description FROM Documents"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(DISTINCT template_id) FROM Documents", "question": "How many different templates do all document use?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find all the templates used by the documents. Secondly, we need to count the number of different templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Templates'] to find the templates used by the documents.\n\n<3> SQL Generation: We can join the 'Documents' and 'Templates' tables on the 'Template_ID' column. Then, we can count the number of distinct 'Template_ID' values.\n\n", "predict": "SELECT COUNT(DISTINCT T2.Template_ID) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(DISTINCT template_id) FROM Documents", "question": "Count the number of different templates used for documents.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of different templates used for documents. This can be achieved by counting the distinct values of the 'Template_ID' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'Documents' and 'Templates' tables, as we are interested in the 'Template_ID' column in the 'Documents' table.\n\n<3> SQL Generation: We use the 'COUNT(DISTINCT)' function to count the number of distinct values in the 'Template_ID' column of the 'Documents' table.\n\n", "predict": "SELECT COUNT(DISTINCT Template_ID) FROM Documents"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Templates", "question": "How many templates do we have?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of templates, we only need to use the 'Templates' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of templates in the 'Templates' table.\n\n", "predict": "SELECT count(*) FROM Templates"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Templates", "question": "Count the number of templates.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query requires counting the number of templates, we only need to use the 'Templates' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'Templates' table.\n\n", "predict": "SELECT count(*) FROM Templates"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_id ,  version_number ,  template_type_code FROM Templates", "question": "Show template ids, version numbers, and template type codes for all templates.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'].\n\n<2> SQL Generation: We need to select the 'Template_ID', 'Version_Number', and 'Template_Type_Code' columns from the 'Templates' table.\n\n", "predict": "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_id ,  version_number ,  template_type_code FROM Templates", "question": "What are the ids, version numbers, and type codes for each template?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'] to get the template ids, version numbers, and type codes.\n\n<2> SQL Generation: We can select the 'Template_ID', 'Version_Number', and 'Template_Type_Code' columns from the 'Templates' table.\n\n", "predict": "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT DISTINCT template_type_code FROM Templates", "question": "Show all distinct template type codes for all templates.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'].\n\n<2> SQL Generation: We need to select the distinct 'Template_Type_Code' column from the 'Templates' table.\n\n", "predict": "SELECT DISTINCT Template_Type_Code FROM Templates"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT DISTINCT template_type_code FROM Templates", "question": "What are the different template type codes?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the different template type codes, we need to use the 'Template_Type_Code' column from the 'Ref_Template_Types' table.\n\n<2> SQL Generation: We can simply select the distinct values from the 'Template_Type_Code' column in the 'Ref_Template_Types' table.\n\n", "predict": "SELECT DISTINCT Template_Type_Code FROM Ref_Template_Types"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code", "question": "Show all template type codes and number of templates for each.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires showing all template type codes and the number of templates for each type. To achieve this, we need to perform a 'GROUP BY' operation on the column 'Template_Type_Code' in the 'Templates' table and count the number of templates for each type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates'] to get the template type codes and ['Documents'] to count the number of templates for each type.\n\n<3> SQL Generation: We join the 'Templates' and 'Documents' tables on the 'Template_ID' column. Then, we group the rows by the 'Template_Type_Code' column and count the number of templates for each type.\n\n", "predict": "SELECT T1.Template_Type_Code, COUNT(*) AS Number_of_Templates FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID GROUP BY T1.Template_Type_Code"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "question": "What the smallest version number and its template type code?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the smallest version number from the 'Templates' table. Secondly, we need to retrieve the corresponding template type code from the 'Ref_Template_Types' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'].\n\n<3> SQL Generation: We can use the 'MIN' function to find the smallest version number from the 'Templates' table. Then, we can join the 'Templates' and 'Ref_Template_Types' tables on the 'Template_Type_Code' column to retrieve the corresponding template type code.\n\n", "predict": "SELECT MIN(T1.Version_Number), T2.Template_Type_Code FROM Templates AS T1 JOIN Ref_Template_Types AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "question": "Return the lowest version number, along with its corresponding template type code.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the lowest version number along with its corresponding template type code. This can be achieved by selecting the 'Version_Number' and 'Template_Type_Code' columns from the 'Templates' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'Templates' table for this query.\n\n<3> SQL Generation: We can simply select the 'Version_Number' and 'Template_Type_Code' columns from the 'Templates' table and order them in ascending order. Then, we can limit the result to the first row to get the lowest version number along with its corresponding template type code.\n\n", "predict": "SELECT Version_Number, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"", "question": "Return the template type code of the template that is used by a document named Data base.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the document with the name \"Data base\". Secondly, we need to retrieve the template ID of that document. Finally, we need to find the template type code associated with that template ID.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Templates', 'Ref_Template_Types'].\n\n<3> SQL Generation: We can use a combination of 'JOIN' and 'WHERE' clauses to retrieve the template type code based on the document name.\n\n", "predict": "\nSELECT T3.Template_Type_Code \nFROM Documents AS T1 \nJOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID \nJOIN Ref_Template_Types AS T3 ON T2.Template_Type_Code = T3.Template_Type_Code \nWHERE T1.Document_Name = 'Data base'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"", "question": "Show all document names using templates with template type code BK.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query requires document names and template type code, we need to use tables ['Documents', 'Templates', 'Ref_Template_Types'].\n\n<2> SQL Generation: We need to join the 'Documents', 'Templates', and 'Ref_Template_Types' tables on the 'Template_ID' column. Then, we filter the rows where 'Template_Type_Code' is 'BK'. Finally, we select the 'Document_Name' column from the 'Documents' table.\n\n", "predict": "\nSELECT D.Document_Name \nFROM Documents AS D \nJOIN Templates AS T ON D.Template_ID = T.Template_ID \nJOIN Ref_Template_Types AS RTT ON T.Template_Type_Code = RTT.Template_Type_Code \nWHERE RTT.Template_Type_Code = 'BK'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1", "question": "Return the code of the template type that is most commonly used in documents.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the occurrences of each template type in the 'Documents' table. Secondly, we need to find the template type with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Templates', 'Ref_Template_Types'].\n\n<3> SQL Generation: We need to join the 'Documents', 'Templates', and 'Ref_Template_Types' tables on the appropriate columns. Then, we group the rows by the template type code and count the occurrences. Finally, we select the template type code with the highest count.\n\n", "predict": "\nSELECT T3.Template_Type_Code \nFROM Documents AS T1 \nJOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID \nJOIN Ref_Template_Types AS T3 ON T2.Template_Type_Code = T3.Template_Type_Code \nGROUP BY T3.Template_Type_Code \nORDER BY COUNT(*) DESC \nLIMIT 1"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code ,  template_type_description FROM Ref_template_types", "question": "What are the type codes and descriptions for all template types?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Ref_Template_Types'] to get the type codes and descriptions for all template types.\n\n<2> SQL Generation: We simply need to select the 'Template_Type_Code' and 'Template_Type_Description' columns from the 'Ref_Template_Types' table.\n\n", "predict": "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"", "question": "Return the template type description of the template type with the code AD.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the template type description of the template type with the code AD. We need to find the template type description based on the template type code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'].\n\n<3> SQL Generation: We need to join the 'Templates' and 'Ref_Template_Types' tables on the 'Template_Type_Code' column. Then, we filter the rows where 'Template_Type_Code' is 'AD' and select the 'Template_Type_Description' column.\n\n", "predict": "SELECT Template_Type_Description FROM Templates AS T1 JOIN Ref_Template_Types AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code WHERE T1.Template_Type_Code = 'AD'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"", "question": "What is the template type code for template type description \"Book\".", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the template type description \"Book\" in the table 'Ref_Template_Types'. Secondly, we need to retrieve the corresponding template type code from the same table.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step. We only need to use the table 'Ref_Template_Types' and its column 'Template_Type_Code' and 'Template_Type_Description'.\n\n<3> SQL Generation: We can use a simple 'SELECT' statement to retrieve the template type code based on the template type description.\n\n", "predict": "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"", "question": "Return the type code of the template type with the description \"Book\".", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Templates', 'Ref_Template_Types'].\n\n<2> SQL Generation: We need to select the 'Template_Type_Code' column from the 'Ref_Template_Types' table where the 'Template_Type_Description' is \"Book\".\n\n", "predict": "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID", "question": "Return the different descriptions for templates that have been used in a document.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the templates that have been used in a document. Secondly, we need to retrieve the descriptions of these templates and remove any duplicates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Templates', 'Documents'] to find the templates used in a document and table 'Ref_Template_Types' to retrieve the descriptions of these templates.\n\n<3> SQL Generation: We can join the 'Templates' and 'Documents' tables on the 'Template_ID' column to find the templates used in a document. Then, we can join the result with the 'Ref_Template_Types' table on the 'Template_Type_Code' column to retrieve the descriptions of these templates. Finally, we can use the 'DISTINCT' keyword to remove any duplicates in the descriptions.\n\n", "predict": "\nSELECT DISTINCT T3.Template_Type_Description \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nJOIN Ref_Template_Types AS T3 ON T1.Template_Type_Code = T3.Template_Type_Code"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Paragraphs", "question": "How many paragraphs in total?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the total number of paragraphs, so we can directly count the number of rows in the 'Paragraphs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to count the number of paragraphs, we only need to use the 'Paragraphs' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'Paragraphs' table.\n\n", "predict": "SELECT count(*) FROM Paragraphs"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Paragraphs", "question": "Count the number of paragraphs.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to count the number of paragraphs, we only need to use the 'Paragraphs' table.\n\n<2> SQL Generation: We can simply use the 'count' function to count the number of rows in the 'Paragraphs' table.\n\n", "predict": "SELECT count(*) FROM Paragraphs"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'", "question": "How many paragraphs for the document with name 'Summer Show'?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the document with the name 'Summer Show'. Secondly, we need to count the number of paragraphs for that document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Paragraphs'].\n\n<3> SQL Generation: Use 'where' to filter the document with the name 'Summer Show', and then use 'count' to count the number of paragraphs for that document.\n\n", "predict": "SELECT count(*) FROM Paragraphs WHERE Document_ID = (SELECT Document_ID FROM Documents WHERE Document_Name = 'Summer Show')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'", "question": "Count the number of paragraphs in the document named 'Summer Show'.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the document with the name 'Summer Show'. Secondly, we need to count the number of paragraphs in that document.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Paragraphs'].\n\n<3> SQL Generation: Use 'where' to filter the document with the name 'Summer Show', and then use 'count' to count the number of paragraphs in that document.\n\n", "predict": "SELECT count(*) FROM Paragraphs WHERE Document_ID = (SELECT Document_ID FROM Documents WHERE Document_Name = 'Summer Show')"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "select other_details from paragraphs where paragraph_text like 'korea'", "question": "What are the details for the paragraph that includes the text 'Korea ' ?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the paragraph that includes the text 'Korea'. Secondly, we need to retrieve the details for that paragraph.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Paragraphs'].\n\n<3> SQL Generation: We use the 'LIKE' operator to search for the paragraph that includes the text 'Korea'. Then, we retrieve the details for that paragraph.\n\n", "predict": "SELECT * FROM Paragraphs WHERE Paragraph_Text LIKE '%Korea%'"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"", "question": "Show all paragraph texts for the document \"Customer reviews\".", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Documents', 'Paragraphs'].\n\n<2> SQL Generation: We need to select the 'Paragraph_Text' column from the 'Paragraphs' table. To filter the paragraphs for the document \"Customer reviews\", we need to join the 'Documents' table on the 'Document_ID' column and add a condition to select only the rows where the 'Document_Name' is \"Customer reviews\".\n\n", "predict": "SELECT Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = \"Customer reviews\""}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1", "question": "Return the id of the document with the fewest paragraphs.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of paragraphs for each document. Secondly, we need to find the document with the fewest paragraphs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Paragraphs'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'Document_ID' in the 'Paragraphs' table to count the number of paragraphs for each document. Then, we can use the 'MIN' function to find the document with the fewest paragraphs.\n\n<4> SQL Generation: We select the 'Document_ID' column from the 'Documents' table and join it with the 'Paragraphs' table on the 'Document_ID' column. We group by 'Document_ID' and use the 'MIN' function on the count of paragraphs. Finally, we order the result in ascending order and limit it to 1.\n\n", "predict": "SELECT T1.Document_ID FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID = T2.Document_ID GROUP BY T1.Document_ID ORDER BY COUNT(*) ASC LIMIT 1"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2", "question": "What is the document id with 1 to 2 paragraphs?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of paragraphs for each document. Secondly, we need to filter the documents that have 1 to 2 paragraphs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Documents', 'Paragraphs'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'Document_ID' in the 'Paragraphs' table to count the number of paragraphs for each document. Then, we need to filter the documents that have 1 to 2 paragraphs.\n\n<4> SQL Generation: Use 'HAVING' to filter the documents that have 1 to 2 paragraphs, and select the 'Document_ID' column.\n\n", "predict": "SELECT Document_ID FROM Paragraphs GROUP BY Document_ID HAVING COUNT(*) >= 1 AND COUNT(*) <= 2"}, {"db_id": "course_teach", "gold": "SELECT count(*) FROM teacher", "question": "How many teachers are there?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of teachers, so we can directly count the number of rows in the 'teacher' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only asks for the number of teachers, we only need to use the 'teacher' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'teacher' table.\n\n", "predict": "SELECT count(*) FROM teacher"}, {"db_id": "course_teach", "gold": "SELECT count(*) FROM teacher", "question": "What is the total count of teachers?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the total count of teachers, we only need to use the 'teacher' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'teacher' table.\n\n", "predict": "SELECT count(*) FROM teacher"}, {"db_id": "course_teach", "gold": "SELECT Age ,  Hometown FROM teacher", "question": "What are the age and hometown of teachers?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the age and hometown of teachers, we need to use tables ['teacher'].\n\n<2> SQL Generation: We need to select the 'Age' and 'Hometown' columns from the 'teacher' table.\n\n", "predict": "SELECT Age, Hometown FROM teacher"}, {"db_id": "course_teach", "gold": "SELECT Age ,  Hometown FROM teacher", "question": "What is the age and hometown of every teacher?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher'].\n\n<2> SQL Generation: We need to select the 'Age' and 'Hometown' columns from the 'teacher' table.\n\n", "predict": "SELECT Age, Hometown FROM teacher"}, {"db_id": "course_teach", "gold": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1", "question": "Where is the youngest teacher from?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the hometown of the youngest teacher, so we need to find the youngest teacher based on their age and then retrieve their hometown.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher'] to find the youngest teacher and retrieve their hometown.\n\n<3> Operation: We need to find the minimum age from the 'Age' column in the 'teacher' table to identify the youngest teacher.\n\n<4> SQL Generation: We select the 'Hometown' column from the 'teacher' table where the 'Age' column is equal to the minimum age.\n\n", "predict": "SELECT Hometown FROM teacher WHERE Age = (SELECT MIN(Age) FROM teacher)"}, {"db_id": "course_teach", "gold": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID", "question": "What is the name of each teacher and what course they teach?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher', 'course', 'course_arrange'].\n\n<2> SQL Generation: We need to join the 'teacher', 'course', and 'course_arrange' tables on the 'Teacher_ID' and 'Course_ID' columns. Then, we select the 'Name' column from the 'teacher' table and the 'Course' column from the 'course' table.\n\n", "predict": "SELECT T1.Name, T2.Course FROM teacher AS T1 JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID JOIN course AS T3 ON T2.Course_ID = T3.Course_ID"}, {"db_id": "course_teach", "gold": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"", "question": "Show the name of the teacher for the math course.", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the course with the name 'math'. Secondly, we need to find the teacher who teaches that course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['course', 'course_arrange', 'teacher'].\n\n<3> SQL Generation: Use 'where' to filter the course with the name 'math', and then join the 'course_arrange' and 'teacher' tables on the 'Teacher_ID' column. Finally, select the 'Name' column from the 'teacher' table.\n\n", "predict": "SELECT T3.Name FROM course AS T1 JOIN course_arrange AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T2.Teacher_ID = T3.Teacher_ID WHERE T1.Course = 'math'"}, {"db_id": "wta_1", "gold": "SELECT count(*) FROM players", "question": "Find the total number of players.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the total number of players, we only need to use the 'players' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'players' table.\n\n", "predict": "SELECT count(*) FROM players"}, {"db_id": "wta_1", "gold": "SELECT count(*) FROM players", "question": "How many players are there?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of players, we only need to use the 'players' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of players in the 'players' table.\n\n", "predict": "SELECT count(*) FROM players"}, {"db_id": "wta_1", "gold": "SELECT count(*) FROM matches", "question": "Find the total number of matches.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the total number of matches, we need to use the 'matches' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'matches' table.\n\n", "predict": "SELECT count(*) FROM matches"}, {"db_id": "wta_1", "gold": "SELECT count(*) FROM matches", "question": "Count the number of matches.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To count the number of matches, we need to use the 'matches' table.\n\n<2> SQL Generation: We can simply use the 'count' function to count the number of rows in the 'matches' table.\n\n", "predict": "SELECT count(*) FROM matches"}, {"db_id": "wta_1", "gold": "SELECT min(loser_rank) FROM matches", "question": "Find the highest rank of losers in all matches.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to find the highest rank of losers in all matches. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['matches', 'players'].\n\n<3> Operation: We need to find the highest rank of losers, so we should use the 'MAX' operation on the 'loser_rank' column in the 'matches' table.\n\n<4> SQL Generation: We select the 'loser_rank' column from the 'matches' table and use the 'MAX' operation to find the highest rank.\n\n", "predict": "SELECT MAX(loser_rank) FROM matches"}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT country_code) FROM players", "question": "How many distinct countries do players come from?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'players' table to get the distinct countries.\n\n<2> SQL Generation: We can use the 'DISTINCT' keyword to select the distinct countries from the 'country_code' column in the 'players' table. Then, we can use the 'COUNT' function to count the number of distinct countries.\n\n", "predict": "SELECT COUNT(DISTINCT country_code) FROM players"}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT loser_name) FROM matches", "question": "Find the number of distinct name of losers.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to find the distinct names of losers from the 'players' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'players' table.\n\n<3> SQL Generation: We can use the 'DISTINCT' keyword to select the distinct names from the 'players' table.\n\n", "predict": "SELECT COUNT(DISTINCT last_name) FROM players"}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT loser_name) FROM matches", "question": "How many different loser names are there?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires counting the number of different loser names. So we need to select the distinct loser names from the 'matches' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'matches' table for this query.\n\n<3> SQL Generation: Use the 'SELECT DISTINCT' statement to select the distinct loser names from the 'matches' table. Then, use the 'COUNT' function to count the number of distinct loser names.\n\n", "predict": "SELECT COUNT(DISTINCT loser_name) FROM matches"}, {"db_id": "wta_1", "gold": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1", "question": "Find the first name and country code of the player who did the most number of tours.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires finding the player who did the most number of tours, so we should apply the 'count' operation to table 'rankings', and sort it in descending order. Since the unit to which the tours being counted in the query belong is player and only table 'rankings' has column 'player_id', so we should apply the 'group by' operation to column 'player_id' in table 'rankings'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Due to the direct foreign key connection between table 'players' and 'rankings'. We need to use tables ['players', 'rankings'].\n\n<3> SQL generation: The query requires the first name and country code of the player who did the most number of tours, so we should select the 'first_name' and 'country_code' columns in the 'players' table. The query does not require the count of most tours, so it is only used for filtering and not selected. \n\n", "predict": "SELECT T1.first_name, T1.country_code FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T2.player_id ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "wta_1", "gold": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1", "question": "What are the names of the winner and loser who played in the longest match?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the longest match by selecting the maximum value of the 'minutes' column from the 'matches' table. Secondly, we need to retrieve the names of the winner and loser who played in that match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['matches', 'players'] to retrieve the names of the winner and loser.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the match with the longest duration, and then use 'join' to retrieve the names of the winner and loser based on their respective player IDs.\n\n", "predict": "\nSELECT p1.first_name AS winner_first_name, p1.last_name AS winner_last_name, p2.first_name AS loser_first_name, p2.last_name AS loser_last_name\nFROM matches AS m\nJOIN players AS p1 ON m.winner_id = p1.player_id\nJOIN players AS p2 ON m.loser_id = p2.player_id\nWHERE m.minutes = (SELECT MAX(minutes) FROM matches)"}, {"db_id": "battle_death", "gold": "SELECT name ,  date FROM battle", "question": "List the name, date and result of each battle.", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the table 'battle' to retrieve the name, date, and result of each battle.\n\n<2> SQL Generation: We can simply select the name, date, and result columns from the 'battle' table to retrieve the desired information.\n\n", "predict": "SELECT name, date, result FROM battle"}, {"db_id": "battle_death", "gold": "SELECT avg(injured) FROM death", "question": "What is the average number of injuries caused each time?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to calculate the average number of injuries caused each time. To do this, we need to sum up the number of injuries from the 'death' table and divide it by the total number of battles.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['battle', 'death'].\n\n<3> Operation: We need to perform a 'SUM' operation on the 'injured' column in the 'death' table to get the total number of injuries. We also need to perform a 'COUNT' operation on the 'id' column in the 'battle' table to get the total number of battles.\n\n<4> SQL Generation: We calculate the average number of injuries by dividing the sum of injuries by the count of battles.\n\n", "predict": "SELECT SUM(injured) / COUNT(DISTINCT battle.id) AS average_injuries FROM death JOIN ship ON death.caused_by_ship_id = ship.id JOIN battle ON ship.lost_in_battle = battle.id"}, {"db_id": "battle_death", "gold": "SELECT count(DISTINCT RESULT) FROM battle", "question": "How many different results are there for the battles?", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the table 'battle' to get the different results for the battles.\n\n<2> SQL Generation: We need to select the distinct values from the 'result' column in the 'battle' table and count them.\n\n", "predict": "SELECT COUNT(DISTINCT result) FROM battle"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT line_1 ,  line_2 FROM addresses", "question": "what are all the addresses including line 1 and line 2?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to retrieve address information, we should use the 'Addresses' table.\n\n<2> SQL Generation: To retrieve all the addresses including line 1 and line 2, we can simply select the 'line_1' and 'line_2' columns from the 'Addresses' table.\n\n", "predict": "SELECT line_1, line_2 FROM Addresses"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT line_1 ,  line_2 FROM addresses", "question": "What is the first and second line for all addresses?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the table and column that should be used based on the requirements of the query. We need to use the 'Addresses' table and select the 'line_1' and 'line_2' columns.\n\n<2> SQL Generation: We simply need to select the 'line_1' and 'line_2' columns from the 'Addresses' table.\n\n", "predict": "SELECT line_1, line_2 FROM Addresses"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Courses", "question": "How many courses in total are listed?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the total number of courses listed, we only need to use the 'Courses' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of courses in the 'Courses' table.\n\n", "predict": "SELECT count(*) FROM Courses"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Courses", "question": "How many courses are there?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of courses, we need to use the 'Courses' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of courses in the 'Courses' table.\n\n", "predict": "SELECT count(*) FROM Courses"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT course_description FROM Courses WHERE course_name  =  'math'", "question": "How is the math course described?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the description of a math course, we need to use the 'Courses' table.\n\n<2> SQL Generation: We need to select the 'course_description' column from the 'Courses' table where the 'course_name' is 'math'.\n\n", "predict": "SELECT course_description FROM Courses WHERE course_name = 'math'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT course_description FROM Courses WHERE course_name  =  'math'", "question": "What are the descriptions for all the math courses?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the courses that are related to math. Secondly, we need to select the descriptions of these math courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Courses'] to filter the math courses and select their descriptions.\n\n<3> SQL Generation: Use 'where' to filter the courses that are related to math and select their descriptions.\n\n", "predict": "SELECT course_description FROM Courses WHERE course_name LIKE '%math%'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT department_id) FROM Degree_Programs", "question": "How many departments offer any degree?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the number of departments that offer any degree. So we need to count the distinct departments from the 'Degree_Programs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'Degree_Programs' table to count the distinct departments.\n\n<3> SQL Generation: We use the 'COUNT(DISTINCT)' function to count the distinct departments from the 'Degree_Programs' table.\n\n", "predict": "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT department_id) FROM Degree_Programs", "question": "How many different departments offer degrees?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of different departments that offer degrees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Departments', 'Degree_Programs'].\n\n<3> SQL Generation: We need to join the 'Departments' and 'Degree_Programs' tables on the 'department_id' column. Then, we count the number of distinct 'department_id' values in the 'Degree_Programs' table.\n\n", "predict": "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs", "question": "How many different degree names are offered?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the number of different degree names offered. To achieve this, we need to select the distinct degree names from the 'Degree_Programs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires information from the 'Degree_Programs' table, we only need to use that table.\n\n<3> SQL Generation: We need to select the distinct 'degree_summary_name' column from the 'Degree_Programs' table and count the number of distinct values.\n\n", "predict": "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs", "question": "How many different degrees are offered?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the number of different degrees offered. To do this, we need to count the distinct degree_program_id values in the Degree_Programs table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the Degree_Programs table for this query.\n\n<3> SQL Generation: We use the COUNT and DISTINCT functions to count the number of distinct degree_program_id values in the Degree_Programs table.\n\n", "predict": "SELECT COUNT(DISTINCT degree_program_id) FROM Degree_Programs"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'", "question": "How many degrees does the engineering department offer?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to identify the department with the name 'engineering'. Secondly, we need to count the number of degrees offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Departments', 'Degree_Programs'].\n\n<3> SQL Generation: We need to join the 'Departments' and 'Degree_Programs' tables on the 'department_id' column. Then, we filter the rows where the 'department_name' is 'engineering'. Finally, we count the number of distinct 'degree_program_id' values.\n\n", "predict": "SELECT COUNT(DISTINCT degree_program_id) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineering'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'", "question": "How many degrees does the engineering department have?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the degrees based on the department. Secondly, we need to count the number of degrees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Departments', 'Degree_Programs'].\n\n<3> SQL Generation: We need to join the 'Departments' and 'Degree_Programs' tables on the 'department_id' column. Then, we filter the rows where the department name is 'Engineering'. Finally, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id = T2.department_id WHERE T2.department_name = 'Engineering'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT section_name ,  section_description FROM Sections", "question": "What are the names and descriptions of all the sections?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the names and descriptions of all the sections, we need to use the 'Sections' table.\n\n<2> SQL Generation: We can simply select the 'section_name' and 'section_description' columns from the 'Sections' table to retrieve the names and descriptions of all the sections.\n\n", "predict": "SELECT section_name, section_description FROM Sections"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT section_name ,  section_description FROM Sections", "question": "What are the names and descriptions for all the sections?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the names and descriptions for all the sections, we need to use the 'Sections' table.\n\n<2> SQL Generation: We can simply select the 'section_name' and 'section_description' columns from the 'Sections' table to retrieve the names and descriptions for all the sections.\n\n", "predict": "SELECT section_name, section_description FROM Sections"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT section_name FROM Sections ORDER BY section_name DESC", "question": "List the section_name in reversed lexicographical order.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires listing the section names in reversed lexicographical order. This can be achieved by selecting the section names from the 'Sections' table and ordering them in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need the section names, we only need to use the 'Sections' table.\n\n<3> SQL Generation: Use the 'SELECT' statement to select the 'section_name' column from the 'Sections' table. Then, use the 'ORDER BY' statement to order the section names in descending order.\n\n", "predict": "SELECT section_name FROM Sections ORDER BY section_name DESC"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT section_name FROM Sections ORDER BY section_name DESC", "question": "What are the names of the sections in reverse alphabetical order?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query requires the names of the sections, we need to use the 'Sections' table.\n\n<2> SQL Generation: To retrieve the names of the sections in reverse alphabetical order, we can use the 'ORDER BY' clause with the 'section_name' column in the 'Sections' table and specify the 'DESC' keyword to indicate descending order.\n\n", "predict": "SELECT section_name FROM Sections ORDER BY section_name DESC"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter students who are enrolled in a Bachelor degree program. Secondly, we need to select the first name, middle name, and last name of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Students', 'Student_Enrolment', 'Degree_Programs'].\n\n<3> SQL Generation: We need to join the 'Students', 'Student_Enrolment', and 'Degree_Programs' tables on the corresponding foreign key columns. Then, we filter the rows where the degree program is a Bachelor degree program. Finally, we select the first name, middle name, and last name columns from the 'Students' table.\n\n", "predict": "SELECT first_name, middle_name, last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1", "question": "Who is the first student to register? List the first name, middle name and last name.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires finding the first student to register, so we should sort the students based on their registration date and select the first one.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Students' table to retrieve the first name, middle name, and last name of the student.\n\n<3> SQL Generation: Use 'order by' and 'asc' to sort the students based on their registration date, and then select the first student's first name, middle name, and last name.\n\n", "predict": "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1", "question": "What is the first, middle, and last name of the first student to register?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the first, middle, and last name of the first student to register. So we need to select the first student to register and retrieve their first, middle, and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'Students' table to retrieve the first student to register and their first, middle, and last name.\n\n<3> SQL Generation: We can use the 'ORDER BY' clause to sort the students by their registration date in ascending order and then use the 'LIMIT' clause to select only the first student. Finally, we select their first, middle, and last name.\n\n", "predict": "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1", "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires finding the earliest graduate of the school, so we should sort the graduation dates in ascending order and select the earliest one. Since the query only requires the name of the earliest graduate, we only need to select the first name, middle name, and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the earliest graduate, we need to use tables ['Students', 'Student_Enrolment', 'Transcripts']. To select the name of the earliest graduate, we need to use table 'Students'.\n\n<3> SQL Generation: We need to join the 'Students', 'Student_Enrolment', and 'Transcripts' tables on the appropriate foreign key columns. Then, we sort the graduation dates in ascending order and select the first row. Finally, we select the first name, middle name, and last name of the earliest graduate.\n\n", "predict": "\nSELECT T1.first_name, T1.middle_name, T1.last_name \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nJOIN Transcripts AS T3 ON T2.transcript_id = T3.transcript_id \nORDER BY T3.transcript_date ASC \nLIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "question": "Which address holds the most number of students currently? List the address id and all lines.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of students for each address. Secondly, we need to find the address with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Addresses', 'Students'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'current_address_id' in the 'Students' table to count the number of students for each address.\n\n<4> SQL Generation: We select the 'address_id' and 'line_1', 'line_2', 'line_3' columns from the 'Addresses' table and join it with the 'Students' table on the 'current_address_id' column. Then, we group by 'current_address_id' and order by the count of students in descending order. Finally, we select the top row to get the address with the highest count.\n\n", "predict": "\nSELECT A.address_id, A.line_1, A.line_2, A.line_3\nFROM Addresses AS A\nJOIN Students AS S ON A.address_id = S.current_address_id\nGROUP BY S.current_address_id\nORDER BY COUNT(*) DESC\nLIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT avg(transcript_date) FROM Transcripts", "question": "On average, when were the transcripts printed?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the average date of transcript printing, so we should apply the 'avg' operation to the column 'transcript_date' in table 'Transcripts'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires information from the 'Transcripts' table, we only need to use the table ['Transcripts'].\n\n<3> SQL generation: The query requires the average date of transcript printing, so we should select the 'transcript_date' column in the 'Transcripts' table and calculate the average.\n\n", "predict": "SELECT AVG(transcript_date) FROM Transcripts"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT avg(transcript_date) FROM Transcripts", "question": "What is the average transcript date?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the average transcript date, so we need to select the 'transcript_date' column from the 'Transcripts' table and calculate the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Transcripts' table for this query.\n\n<3> SQL Generation: We can use the 'AVG()' function to calculate the average transcript date.\n\n", "predict": "SELECT AVG(transcript_date) FROM Transcripts"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1", "question": "When is the first transcript released? List the date and details.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking for information about transcripts, we need to use tables ['Transcripts'].\n\n<2> SQL Generation: We need to select the 'transcript_date' and 'other_details' columns from the 'Transcripts' table. Since we are only interested in the first transcript released, we can use the 'ORDER BY' clause to sort the transcripts by date in ascending order and then use the 'LIMIT' clause to select only the first row.\n\n", "predict": "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1", "question": "What is the earliest date of a transcript release, and what details can you tell me?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the earliest date of a transcript release. Secondly, we need to retrieve the details of the transcript with that earliest release date.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Transcripts'] and ['Transcript_Contents'].\n\n<3> SQL Generation: We can use the 'MIN' function to find the earliest date of a transcript release from the 'transcript_date' column in the 'Transcripts' table. Then, we can join the 'Transcripts' and 'Transcript_Contents' tables on the 'transcript_id' column and retrieve the details of the transcript with the earliest release date.\n\n", "predict": "\nSELECT T1.transcript_date, T2.* \nFROM Transcripts AS T1 \nJOIN Transcript_Contents AS T2 ON T1.transcript_id = T2.transcript_id \nWHERE T1.transcript_date = (SELECT MIN(transcript_date) FROM Transcripts)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Transcripts", "question": "How many transcripts are released?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of transcripts that are released. We can directly count the number of rows in the 'Transcripts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to count the number of transcripts, we only need to use the 'Transcripts' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'Transcripts' table.\n\n", "predict": "SELECT count(*) FROM Transcripts"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(*) FROM Transcripts", "question": "How many transcripts are listed?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query is asking for the number of transcripts listed, so we can directly count the number of rows in the 'Transcripts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is only asking for the number of transcripts listed, we only need to use the 'Transcripts' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'Transcripts' table.\n\n", "predict": "SELECT count(*) FROM Transcripts"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1", "question": "What is the last transcript release date?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the last transcript release date, we need to use the 'Transcripts' table.\n\n<2> SQL Generation: We need to select the 'transcript_date' column from the 'Transcripts' table and order it in descending order. Then, we select the first row to get the last transcript release date.\n\n", "predict": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1", "question": "When was the last transcript released?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the last transcript released, we need to use the 'Transcripts' table.\n\n<2> SQL Generation: We need to select the 'transcript_date' column from the 'Transcripts' table and order it in descending order. Then, we select the first row to get the date of the last transcript released.\n\n", "predict": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1", "question": "What is the date and id of the transcript with the least number of results?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the transcript with the least number of results. Secondly, we need to retrieve the date and id of that transcript.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Transcripts', 'Transcript_Contents'] to find the transcript with the least number of results.\n\n<3> SQL Generation: We can use the 'count' function to calculate the number of results for each transcript in the 'Transcript_Contents' table. Then, we can select the transcript with the minimum count and retrieve its date and id from the 'Transcripts' table.\n\n", "predict": "\nSELECT T1.transcript_date, T1.transcript_id \nFROM Transcripts AS T1 \nJOIN Transcript_Contents AS T2 ON T1.transcript_id = T2.transcript_id \nGROUP BY T2.transcript_id \nORDER BY COUNT(*) ASC \nLIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT count(DISTINCT current_address_id) FROM Students", "question": "How many different addresses do the students currently live?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to identify the addresses that the students currently live in. Secondly, we need to count the number of different addresses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Students', 'Addresses'] to get the current address of the students.\n\n<3> SQL Generation: We join the 'Students' and 'Addresses' tables on the 'current_address_id' column. Then, we count the number of distinct addresses.\n\n", "predict": "SELECT COUNT(DISTINCT current_address_id) FROM Students"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "question": "What is the description for the section named h?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the description for a section with a specific name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'Sections' table to find the section with the specified name.\n\n<3> SQL Generation: We can use a simple 'SELECT' statement to retrieve the description for the section with the specified name.\n\n", "predict": "SELECT section_description FROM Sections WHERE section_name = 'h'"}, {"db_id": "tvshow", "gold": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;", "question": "How many different series and contents are listed in the TV Channel table?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of different series listed in the TV Channel table. Secondly, we need to count the number of different contents listed in the TV Channel table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['TV_Channel'] to count the number of different series and contents.\n\n<3> SQL Generation: We can use the 'count(distinct)' function to count the number of different series and contents in the TV Channel table.\n\n", "predict": "\nSELECT count(distinct series_name) AS num_series, count(distinct Content) AS num_contents FROM TV_Channel"}, {"db_id": "tvshow", "gold": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";", "question": "What is the content of the series Sky Radio?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the content of the series \"Sky Radio\". We need to find the series with the title \"Sky Radio\" and retrieve its content.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['TV_series', 'TV_Channel'] to find the series with the title \"Sky Radio\" and retrieve its content.\n\n<3> SQL Generation: We need to join the 'TV_series' and 'TV_Channel' tables on the 'Channel' column. Then, we filter the rows where the series title is \"Sky Radio\" and select the content column from the 'TV_Channel' table.\n\n", "predict": "SELECT T2.Content FROM TV_series AS T1 JOIN TV_Channel AS T2 ON T1.Channel = T2.id WHERE T1.Title = 'Sky Radio'"}, {"db_id": "tvshow", "gold": "SELECT Episode FROM TV_series ORDER BY rating", "question": "What are all of the episodes ordered by ratings?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires all episodes to be ordered by ratings. So, we need to select all episodes and order them by the 'Rating' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['TV_series'].\n\n<3> SQL Generation: We select all columns from the 'TV_series' table and order them by the 'Rating' column in descending order.\n\n", "predict": "SELECT * FROM TV_series ORDER BY Rating DESC"}, {"db_id": "tvshow", "gold": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";", "question": "When did the episode \"A Love of a Lifetime\" air?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the episode with the title \"A Love of a Lifetime\". Secondly, we need to retrieve the air date of that episode.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Cartoon', 'TV_Channel', 'TV_series'].\n\n<3> SQL Generation: We need to join the 'Cartoon', 'TV_Channel', and 'TV_series' tables on the 'Channel' column. Then, we filter the rows where the episode title is \"A Love of a Lifetime\". Finally, we select the 'Air_Date' column from the 'TV_series' table.\n\n", "predict": "\nSELECT T3.Air_Date \nFROM Cartoon AS T1 \nJOIN TV_Channel AS T2 ON T1.Channel = T2.id \nJOIN TV_series AS T3 ON T2.id = T3.Channel \nWHERE T1.Title = 'A Love of a Lifetime'"}, {"db_id": "poker_player", "gold": "SELECT count(*) FROM poker_player", "question": "How many poker players are there?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the table 'poker_player' to count the number of poker players.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'poker_player' table.\n\n", "predict": "SELECT count(*) FROM poker_player"}, {"db_id": "poker_player", "gold": "SELECT count(*) FROM poker_player", "question": "Count the number of poker players.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the table 'poker_player' to count the number of poker players.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'poker_player' table.\n\n", "predict": "SELECT count(*) FROM poker_player"}, {"db_id": "poker_player", "gold": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player", "question": "List the final tables made and the best finishes of poker players.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<2> SQL Generation: We need to select the columns 'Final_Table_Made' and 'Best_Finish' from the table 'poker_player'.\n\n", "predict": "SELECT Final_Table_Made, Best_Finish FROM poker_player"}, {"db_id": "poker_player", "gold": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player", "question": "What are the final tables made and best finishes for all poker players?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<2> SQL Generation: We need to select the columns 'Final_Table_Made' and 'Best_Finish' from the table 'poker_player' to get the final tables made and best finishes for all poker players.\n\n", "predict": "SELECT Final_Table_Made, Best_Finish FROM poker_player"}, {"db_id": "poker_player", "gold": "SELECT avg(Earnings) FROM poker_player", "question": "What is the average earnings of poker players?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the average earnings of poker players, so we should apply the 'avg' operation to the 'Earnings' column in the 'poker_player' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'poker_player' table.\n\n<3> SQL generation: The query requires the average earnings of poker players, so we should select the 'Earnings' column in the 'poker_player' table and apply the 'avg' operation to it.\n\n", "predict": "SELECT AVG(Earnings) FROM poker_player"}, {"db_id": "poker_player", "gold": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1", "question": "What is the money rank of the poker player with the highest earnings?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the poker player with the highest earnings. Secondly, we need to retrieve the money rank of that player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['poker_player', 'people'].\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the poker player with the highest earnings, and then retrieve the money rank of that player.\n\n", "predict": "SELECT money_rank FROM poker_player AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID ORDER BY earnings DESC LIMIT 1"}, {"db_id": "poker_player", "gold": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1", "question": "Return the money rank of the player with the greatest earnings.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the player with the greatest earnings. Secondly, we need to return the money rank of that player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the player with the greatest earnings, and then return the money rank of that player.\n\n", "predict": "SELECT money_rank FROM poker_player ORDER BY earnings DESC LIMIT 1"}, {"db_id": "poker_player", "gold": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID", "question": "What are the names of poker players?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the names of poker players, we need to use tables ['people', 'poker_player'].\n\n<2> SQL Generation: We simply need to select the 'Name' column from the 'people' table.\n\n", "predict": "SELECT Name FROM people"}, {"db_id": "poker_player", "gold": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID", "question": "Return the names of all the poker players.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'people' table to retrieve the names of all the poker players.\n\n<2> SQL Generation: We simply need to select the 'Name' column from the 'people' table.\n\n", "predict": "SELECT Name FROM people"}, {"db_id": "poker_player", "gold": "SELECT count(DISTINCT Nationality) FROM people", "question": "How many distinct nationalities are there?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking for the number of distinct nationalities, we only need to use the 'people' table.\n\n<2> SQL Generation: We can use the 'COUNT(DISTINCT)' function to count the number of distinct nationalities in the 'Nationality' column of the 'people' table.\n\n", "predict": "SELECT COUNT(DISTINCT Nationality) FROM people"}, {"db_id": "poker_player", "gold": "SELECT count(DISTINCT Nationality) FROM people", "question": "Count the number of different nationalities.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query requires counting the number of different nationalities, we only need to use the 'people' table.\n\n<2> Operation: To count the number of different nationalities, we need to perform a 'GROUP BY' operation on the 'Nationality' column and then count the number of distinct nationalities.\n\n<3> SQL Generation: Use 'GROUP BY' and 'COUNT(DISTINCT)' to count the number of different nationalities.\n\n", "predict": "SELECT COUNT(DISTINCT Nationality) FROM people"}, {"db_id": "voter_1", "gold": "SELECT count(*) FROM area_code_state", "question": "How many states are there?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking for the number of states, we only need to use the 'AREA_CODE_STATE' table.\n\n<2> SQL Generation: We can use the 'COUNT' function to count the number of distinct states in the 'AREA_CODE_STATE' table.\n\n", "predict": "SELECT COUNT(DISTINCT state) FROM AREA_CODE_STATE"}, {"db_id": "voter_1", "gold": "SELECT vote_id ,  phone_number ,  state FROM votes", "question": "List the vote ids, phone numbers and states of all votes.", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use tables ['VOTES'].\n\n<2> SQL Generation: We need to select the columns 'vote_id', 'phone_number', and 'state' from the table 'VOTES'.\n\n", "predict": "SELECT vote_id, phone_number, state FROM VOTES"}, {"db_id": "voter_1", "gold": "SELECT count(*) FROM contestants WHERE contestant_number NOT IN ( SELECT contestant_number FROM votes )", "question": "How many contestants did not get voted?", "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n", "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n", "types": {"AREA_CODE_STATE.area_code": "number", "AREA_CODE_STATE.state": "text", "CONTESTANTS.contestant_number": "number", "CONTESTANTS.contestant_name": "text", "VOTES.vote_id": "number", "VOTES.phone_number": "number", "VOTES.state": "text", "VOTES.contestant_number": "number", "VOTES.created": "time"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of contestants who did not receive any votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['CONTESTANTS', 'VOTES'].\n\n<3> SQL Generation: We can use a 'LEFT JOIN' operation to join the 'CONTESTANTS' table with the 'VOTES' table on the 'contestant_number' column. Then, we can filter the rows where the 'vote_id' is null (indicating no votes) and count the number of rows.\n\n", "predict": "SELECT COUNT(*) FROM CONTESTANTS LEFT JOIN VOTES ON CONTESTANTS.contestant_number = VOTES.contestant_number WHERE VOTES.vote_id IS NULL"}, {"db_id": "world_1", "gold": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"", "question": "How much surface area do the countires in the Carribean cover together?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to identify the countries in the Caribbean. Secondly, we need to calculate the total surface area of these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country'] and ['countrylanguage'] to identify the countries in the Caribbean.\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where 'Region' is 'Caribbean'. Finally, we sum the 'SurfaceArea' column to calculate the total surface area of the Caribbean countries.\n\n", "predict": "SELECT SUM(country.SurfaceArea) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Region = 'Caribbean'"}, {"db_id": "world_1", "gold": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"", "question": "Which continent is Anguilla in?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to find the continent of Anguilla, we need to use the 'country' table.\n\n<2> SQL Generation: We need to select the 'Continent' column from the 'country' table where the 'Name' column is 'Anguilla'.\n\n", "predict": "SELECT Continent FROM country WHERE Name = 'Anguilla'"}, {"db_id": "world_1", "gold": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"", "question": "What is the continent name which Anguilla belongs to?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to find the continent name which Anguilla belongs to, we need to use tables ['country'].\n\n<2> SQL Generation: We need to select the 'Continent' column from the 'country' table where the 'Name' column is 'Anguilla'.\n\n", "predict": "SELECT Continent FROM country WHERE Name = 'Anguilla'"}, {"db_id": "world_1", "gold": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"", "question": "Which region is the city Kabul located in?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking about the region of a city, we need to use tables ['city', 'country'].\n\n<2> SQL Generation: We need to join the 'city' and 'country' tables on the 'CountryCode' column. Then, we filter the row where the city name is 'Kabul' and select the 'Region' column.\n\n", "predict": "SELECT country.Region FROM city JOIN country ON city.CountryCode = country.Code WHERE city.Name = 'Kabul'"}, {"db_id": "world_1", "gold": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"", "question": "What region is Kabul in?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the region of Kabul, we need to use tables ['city', 'country'].\n\n<2> SQL Generation: We need to join the 'city' and 'country' tables on the 'CountryCode' column. Then, we filter the row where the 'Name' column in the 'city' table is 'Kabul'. Finally, we select the 'Region' column from the 'country' table.\n\n", "predict": "SELECT country.Region FROM city JOIN country ON city.CountryCode = country.Code WHERE city.Name = 'Kabul'"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1", "question": "Which language is the most popular in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country code for Aruba. Secondly, we need to filter the country code in the table 'countrylanguage' and select the language with the highest percentage.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where 'Name' is 'Aruba'. Finally, we select the language with the highest 'Percentage' column.\n\n", "predict": "SELECT Language FROM countrylanguage AS T1 JOIN country AS T2 ON T1.CountryCode = T2.Code WHERE T2.Name = 'Aruba' ORDER BY T1.Percentage DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1", "question": "What language is predominantly spoken in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country code for Aruba. Secondly, we need to find the language that is predominantly spoken in Aruba.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where the 'Name' column in the 'country' table is 'Aruba'. Finally, we select the 'Language' column from the 'countrylanguage' table.\n\n", "predict": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' AND T2.Percentage = (SELECT MAX(Percentage) FROM countrylanguage WHERE CountryCode = T1.Code)"}, {"db_id": "world_1", "gold": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"", "question": "What are the population and life expectancies in Brazil?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the population and life expectancies in Brazil, we need to use tables ['country'].\n\n<2> SQL Generation: We need to select the 'Population' and 'LifeExpectancy' columns from the 'country' table where the 'Name' column is 'Brazil'.\n\n", "predict": "SELECT Population, LifeExpectancy FROM country WHERE Name = 'Brazil'"}, {"db_id": "world_1", "gold": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"", "question": "Give me Brazil\u2019s population and life expectancies.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['country'].\n\n<2> SQL Generation: We need to select the 'Population' and 'LifeExpectancy' columns from the 'country' table where the 'Name' column is 'Brazil'.\n\n", "predict": "SELECT Population, LifeExpectancy FROM country WHERE Name = 'Brazil'"}, {"db_id": "world_1", "gold": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"", "question": "What are the region and population of Angola?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the table 'country' to find Angola and retrieve its region and population.\n\n<2> SQL Generation: We can use a simple SELECT statement to retrieve the region and population of Angola from the 'country' table.\n\n", "predict": "SELECT region, population FROM country WHERE name = 'Angola'"}, {"db_id": "world_1", "gold": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"", "question": "What region does Angola belong to and what is its population?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking about Angola, we need to use the 'country' table.\n\n<2> SQL Generation: We need to select the 'Region' and 'Population' columns from the 'country' table where the 'Name' column is 'Angola'.\n\n", "predict": "SELECT Region, Population FROM country WHERE Name = 'Angola'"}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage", "question": "How many unique languages are spoken in the world?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is about languages spoken in the world, we need to use the 'countrylanguage' table.\n\n<2> Operation: The query requires counting the number of unique languages spoken in the world, so we should apply the 'count' operation to the 'Language' column in the 'countrylanguage' table.\n\n<3> SQL Generation: We can use the 'DISTINCT' keyword to select only unique languages from the 'Language' column in the 'countrylanguage' table. Then, we can count the number of unique languages using the 'COUNT' function.\n\n", "predict": "SELECT COUNT(DISTINCT Language) FROM countrylanguage"}, {"db_id": "world_1", "gold": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage", "question": "What is the number of distinct languages used around the world?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the number of distinct languages used around the world, so we need to count the number of distinct languages in the 'countrylanguage' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'countrylanguage' table.\n\n<3> SQL Generation: We need to use the 'count' function to count the number of distinct languages in the 'Language' column of the 'countrylanguage' table.\n\n", "predict": "SELECT COUNT(DISTINCT Language) FROM countrylanguage"}, {"db_id": "world_1", "gold": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"", "question": "How many official languages does Afghanistan have?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the country with the name 'Afghanistan' from the table 'country'. Secondly, we need to count the number of official languages for that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'CountryCode' column. Then, we filter the rows where the country name is 'Afghanistan' and the language is marked as official. Finally, we count the number of rows that meet these conditions.\n\n", "predict": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"}, {"db_id": "world_1", "gold": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"", "question": "How many official languages are spoken in Afghanistan?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country code for Afghanistan. Secondly, we need to filter the rows in the 'countrylanguage' table where the 'CountryCode' is the country code for Afghanistan and the 'IsOfficial' column is set to 'T'. Finally, we need to count the number of rows that meet these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where the 'Name' column in the 'country' table is 'Afghanistan' and the 'IsOfficial' column in the 'countrylanguage' table is 'T'. Finally, we count the number of rows that meet these conditions.\n\n", "predict": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"}, {"db_id": "world_1", "gold": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "question": "Which continent has the most diverse languages?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the number of languages spoken in each continent. Secondly, we need to identify the continent with the highest number of languages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['continent', 'country', 'countrylanguage'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'Continent' in the 'country' table and count the number of distinct languages in each continent.\n\n<4> SQL Generation: We select the 'Continent' column from the 'country' table and count the number of distinct languages in each continent. Then, we order the result in descending order and select the continent with the highest count.\n\n", "predict": "\nSELECT c.Continent\nFROM country AS c\nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode\nGROUP BY c.Continent\nORDER BY COUNT(DISTINCT cl.Language) DESC\nLIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1", "question": "Find the name, population and expected life length of asian country with the largest area?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the Asian country with the largest area. Secondly, we need to retrieve the name, population, and life expectancy of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country'] and ['city'] to retrieve the required information.\n\n<3> SQL Generation: We need to join the 'country' and 'city' tables on the 'CountryCode' column. Then, we filter the rows where 'Continent' is 'Asia' and select the country with the largest 'SurfaceArea'. Finally, we retrieve the 'Name', 'Population', and 'LifeExpectancy' columns for that country.\n\n", "predict": "\nSELECT T1.Name, T1.Population, T1.LifeExpectancy\nFROM country AS T1\nJOIN city AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nORDER BY T1.SurfaceArea DESC\nLIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1", "question": "What are the population, name and leader of the country with the largest area?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country with the largest area. Secondly, we need to retrieve the population, name, and leader of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'country' table to find the country with the largest area and retrieve its population, name, and leader.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the country with the largest area, and then retrieve the population, name, and leader of that country.\n\n", "predict": "SELECT population, name, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1", "question": "Give the name, population, and head of state for the country that has the largest area.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country with the largest area. Secondly, we need to select the name, population, and head of state for that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the table 'country' to find the country with the largest area.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the country with the largest area, and then select the name, population, and head of state for that country.\n\n", "predict": "SELECT name, population, headofstate FROM country ORDER BY surfacearea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3", "question": "Return the names of the 3 countries with the fewest people.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names of the 3 countries with the fewest people, so we should sort the countries based on population in ascending order and select the top 3.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['country'].\n\n<3> SQL Generation: We select the 'Name' column from the 'country' table and sort the countries by population in ascending order. Then, we limit the result to the top 3.\n\n", "predict": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"}, {"db_id": "world_1", "gold": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode", "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the different country codes from the 'country' table. Secondly, for each country, we need to find the language spoken by the greatest percentage of people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: To find the language spoken by the greatest percentage of people for each country, we need to perform a 'GROUP BY' operation on the column 'CountryCode' in the 'countrylanguage' table and find the language with the maximum 'Percentage' for each group.\n\n<4> SQL Generation: We join the 'country' and 'countrylanguage' tables on the 'CountryCode' column. Then, we group the rows by 'CountryCode' and select the language with the maximum 'Percentage' for each group.\n\n", "predict": "\nSELECT T1.Code, T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Percentage = (SELECT MAX(Percentage) FROM countrylanguage WHERE CountryCode = T1.Code)"}, {"db_id": "orchestra", "gold": "SELECT count(*) FROM conductor", "question": "How many conductors are there?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of conductors, so we need to count the distinct values in the 'Conductor_ID' column of the 'conductor' table.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the query requirement. We only need to use the 'conductor' table.\n\n<3> SQL Generation: We use the 'count' function to count the distinct values in the 'Conductor_ID' column of the 'conductor' table.\n\n", "predict": "SELECT COUNT(DISTINCT Conductor_ID) FROM conductor"}, {"db_id": "orchestra", "gold": "SELECT count(*) FROM conductor", "question": "Count the number of conductors.", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires counting the number of conductors, so we can directly count the number of rows in the 'conductor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires counting the number of conductors, we only need to use the 'conductor' table.\n\n<3> SQL Generation: We can use the 'count' function to count the number of rows in the 'conductor' table.\n\n", "predict": "SELECT COUNT(*) FROM conductor"}, {"db_id": "orchestra", "gold": "SELECT count(DISTINCT Nationality) FROM conductor", "question": "How many different nationalities do conductors have?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the number of different nationalities among conductors. So, we need to select the distinct nationalities from the 'conductor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only involves the 'conductor' table, we only need to use the 'conductor' table.\n\n<3> SQL Generation: We need to select the distinct nationalities from the 'conductor' table and count them.\n\n", "predict": "SELECT COUNT(DISTINCT Nationality) FROM conductor"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Highschooler", "question": "How many high schoolers are there?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of high schoolers, we only need to use the 'Highschooler' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'Highschooler' table.\n\n", "predict": "SELECT count(*) FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Highschooler", "question": "Count the number of high schoolers.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query asks for the number of high schoolers, we only need to use the 'Highschooler' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'Highschooler' table.\n\n", "predict": "SELECT count(*) FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT name ,  grade FROM Highschooler", "question": "Show the names and grades of each high schooler.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Highschooler' table to retrieve the names and grades of each high schooler.\n\n<2> SQL Generation: We can simply select the 'name' and 'grade' columns from the 'Highschooler' table to show the names and grades of each high schooler.\n\n", "predict": "SELECT name, grade FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT name ,  grade FROM Highschooler", "question": "What are the names and grades for each high schooler?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Highschooler' table to retrieve the names and grades of each high schooler.\n\n<2> SQL Generation: We can simply select the 'name' and 'grade' columns from the 'Highschooler' table to retrieve the names and grades for each high schooler.\n\n", "predict": "SELECT name, grade FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler", "question": "Show all the grades of the high schoolers.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Highschooler' table to retrieve the grades of the high schoolers.\n\n<2> SQL Generation: We can simply select the 'grade' column from the 'Highschooler' table to retrieve all the grades of the high schoolers.\n\n", "predict": "SELECT grade FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler", "question": "What is the grade of each high schooler?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'Highschooler' table to retrieve the grades of each high schooler.\n\n<2> SQL Generation: We can simply select the 'grade' column from the 'Highschooler' table to get the grade of each high schooler.\n\n", "predict": "SELECT ID, grade FROM Highschooler"}, {"db_id": "network_1", "gold": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"", "question": "What grade is Kyle in?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to find the grade of a student named Kyle, we need to use the 'Highschooler' table.\n\n<2> SQL Generation: We can use the 'name' column in the 'Highschooler' table to filter the row where the name is 'Kyle'. Then, we select the 'grade' column from that row.\n\n", "predict": "SELECT grade FROM Highschooler WHERE name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"", "question": "What is Kyle's id?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we are looking for Kyle's ID, we need to use the 'Highschooler' table.\n\n<2> SQL Generation: We need to select the 'ID' column from the 'Highschooler' table where the 'name' column is 'Kyle'.\n\n", "predict": "SELECT ID FROM Highschooler WHERE name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id", "question": "Show the student IDs and numbers of friends corresponding to each.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'Friend' table to get the student IDs and the 'Likes' table to get the numbers of friends.\n\n<2> SQL Generation: We can use a combination of 'COUNT' and 'GROUP BY' operations to count the number of friends for each student ID.\n\n", "predict": "SELECT Friend.student_id, COUNT(*) AS num_of_friends FROM Friend GROUP BY Friend.student_id"}, {"db_id": "network_1", "gold": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id", "question": "Show the names of high school students and their corresponding number of friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use table 'Highschooler' to get the names of high school students and table 'Friend' to count the number of friends for each student.\n\n<2> Operation: We need to perform a 'GROUP BY' operation on the column 'student_id' in table 'Friend' and use the 'COUNT' function to count the number of friends for each student.\n\n<3> SQL Generation: We join the 'Highschooler' and 'Friend' tables on the 'ID' column. Then, we perform the 'GROUP BY' operation on the 'student_id' column and use the 'COUNT' function to count the number of friends. Finally, we select the 'name' column from the 'Highschooler' table and the count of friends.\n\n", "predict": "\nSELECT H.name, COUNT(F.friend_id) AS num_friends\nFROM Highschooler AS H\nJOIN Friend AS F ON H.ID = F.student_id\nGROUP BY H.ID"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"", "question": "How many friends does the high school student Kyle have?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to find the number of friends that the high school student Kyle has.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'Friend' table to find the friends of Kyle, and the 'Highschooler' table to match the student IDs.\n\n<3> SQL Generation: We need to join the 'Friend' table with the 'Highschooler' table on the 'student_id' column. Then, we filter the rows where the 'name' column in the 'Highschooler' table is 'Kyle'. Finally, we count the number of rows that meet these conditions.\n\n", "predict": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.friend_id = T2.ID WHERE T2.name = 'Kyle'"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"", "question": "Count the number of friends Kyle has.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of friends that Kyle has. To do this, we need to filter the 'Friend' table based on Kyle's ID.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Friend' table in this case.\n\n<3> SQL Generation: We need to filter the rows in the 'Friend' table where the 'student_id' is Kyle's ID. Then, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM Friend WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle')"}, {"db_id": "network_1", "gold": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"", "question": "How many likes does Kyle have?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query asks for the number of likes that Kyle has. We need to filter the likes based on the student_id of Kyle.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'Likes' table.\n\n<3> SQL Generation: We need to filter the rows in the 'Likes' table where the student_id is 'Kyle'. Then, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM Likes WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle')"}, {"db_id": "dog_kennels", "gold": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id", "question": "List the date of each treatment, together with the first name of the professional who operated it.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the date of each treatment, we need to use the 'Treatments' table. To get the first name of the professional who operated the treatment, we need to use the 'Professionals' table.\n\n<2> SQL Generation: We need to join the 'Treatments' and 'Professionals' tables on the 'professional_id' column. Then, we select the 'date_of_treatment' column from the 'Treatments' table and the 'first_name' column from the 'Professionals' table.\n\n", "predict": "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id"}, {"db_id": "dog_kennels", "gold": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id", "question": "What are the date and the operating professional's first name of each treatment?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the date and the operating professional's first name of each treatment. So we need to select the 'date_of_treatment' column from the 'Treatments' table and the 'first_name' column from the 'Professionals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Treatments', 'Professionals'].\n\n<3> SQL Generation: We need to join the 'Treatments' and 'Professionals' tables on the 'professional_id' column. Then, we select the 'date_of_treatment' column from the 'Treatments' table and the 'first_name' column from the 'Professionals' table.\n\n", "predict": "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id"}, {"db_id": "dog_kennels", "gold": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code", "question": "What are the cost and treatment type description of each treatment?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the cost and treatment type description of each treatment, we need to use tables ['Treatments', 'Treatment_Types'].\n\n<2> SQL Generation: We need to join the 'Treatments' and 'Treatment_Types' tables on the 'treatment_type_code' column. Then, we select the 'cost_of_treatment' and 'treatment_type_description' columns from the joined table.\n\n", "predict": "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"}, {"db_id": "dog_kennels", "gold": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "question": "What are each owner's first name, last name, and the size of their dog?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the owner's first name and last name, we need to use the 'Owners' table. To get the size of each owner's dog, we need to use the 'Dogs' table.\n\n<2> SQL Generation: We need to join the 'Owners' and 'Dogs' tables on the 'owner_id' column. Then, we select the 'first_name', 'last_name', and 'size_description' columns from the joined table.\n\n", "predict": "SELECT O.first_name, O.last_name, S.size_description FROM Owners AS O JOIN Dogs AS D ON O.owner_id = D.owner_id JOIN Sizes AS S ON D.size_code = S.size_code"}, {"db_id": "dog_kennels", "gold": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "question": "List pairs of the owner's first name and the dogs's name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Owners', 'Dogs'].\n\n<2> SQL Generation: We need to join the 'Owners' and 'Dogs' tables on the 'owner_id' column. Then, we select the 'first_name' column from the 'Owners' table and the 'name' column from the 'Dogs' table.\n\n", "predict": "SELECT Owners.first_name, Dogs.name FROM Owners JOIN Dogs ON Owners.owner_id = Dogs.owner_id"}, {"db_id": "dog_kennels", "gold": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "question": "Who owns the youngest dog? Give me his or her last name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to find the owner of that dog and retrieve their last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Dogs', 'Owners'] to find the youngest dog and retrieve the owner's last name.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum age of the dogs. Then, we can join the 'Dogs' and 'Owners' tables on the 'owner_id' column to retrieve the last name of the owner.\n\n", "predict": "SELECT O.last_name FROM Dogs AS D JOIN Owners AS O ON D.owner_id = O.owner_id WHERE D.age = (SELECT MIN(age) FROM Dogs)"}, {"db_id": "dog_kennels", "gold": "SELECT date_arrived ,  date_departed FROM Dogs", "question": "What are the arriving date and the departing date of all the dogs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the arriving date and departing date of all the dogs, we need to use the 'Dogs' table.\n\n<2> SQL Generation: We simply need to select the 'date_arrived' and 'date_departed' columns from the 'Dogs' table.\n\n", "predict": "SELECT date_arrived, date_departed FROM Dogs"}, {"db_id": "dog_kennels", "gold": "SELECT date_arrived ,  date_departed FROM Dogs", "question": "List the arrival date and the departure date for all the dogs.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the arrival date and departure date for all the dogs, we need to use the 'Dogs' table.\n\n<2> SQL Generation: We simply need to select the 'date_arrived' and 'date_departed' columns from the 'Dogs' table.\n\n", "predict": "SELECT date_arrived, date_departed FROM Dogs"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT dog_id) FROM Treatments", "question": "How many dogs went through any treatments?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to count the number of dogs that went through any treatments. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Dogs', 'Treatments'].\n\n<3> SQL Generation: We can count the number of dogs by counting the distinct dog IDs in the 'Treatments' table.\n\n", "predict": "SELECT COUNT(DISTINCT dog_id) FROM Treatments"}, {"db_id": "dog_kennels", "gold": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1", "question": "How much does the most recent treatment cost?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recent treatment. Secondly, we need to retrieve the cost of that treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Treatments'] to find the most recent treatment and retrieve its cost.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent treatment, and then retrieve its cost.\n\n", "predict": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1", "question": "Show me the cost of the most recently performed treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recently performed treatment. Secondly, we need to retrieve the cost of that treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the treatment_id with the most recent date_of_treatment from the table 'Treatments'. In the second step, we need to retrieve the cost_of_treatment from the table 'Treatments' based on the treatment_id.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the treatment_id with the most recent date_of_treatment, and then retrieve the cost_of_treatment based on that treatment_id.\n\n", "predict": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT avg(age) FROM Dogs", "question": "What is the average age of all the dogs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the average age of all the dogs, so we should apply the 'avg' operation to the 'age' column in the 'Dogs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires information from the 'Dogs' table, we only need to use the 'Dogs' table.\n\n<3> SQL generation: The query requires the average age of all the dogs, so we should select the 'age' column in the 'Dogs' table and calculate the average using the 'avg' function.\n\n", "predict": "SELECT AVG(age) FROM Dogs"}, {"db_id": "dog_kennels", "gold": "SELECT max(age) FROM Dogs", "question": "What is the age of the oldest dog?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: In this step, we need to find the oldest dog, so we should select the maximum age from the 'Dogs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to find the age of the oldest dog, we only need to use the 'Dogs' table.\n\n<3> SQL Generation: Use the 'MAX' function to select the maximum age from the 'Dogs' table.\n\n", "predict": "SELECT MAX(age) FROM Dogs"}, {"db_id": "dog_kennels", "gold": "SELECT max(age) FROM Dogs", "question": "Tell me the age of the oldest dog.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires finding the age of the oldest dog, so we need to select the maximum age from the 'Dogs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need to retrieve information from the 'Dogs' table, we only need to use the 'Dogs' table.\n\n<3> SQL Generation: We can use the 'MAX' function to select the maximum age from the 'Dogs' table.\n\n", "predict": "SELECT MAX(age) FROM Dogs"}, {"db_id": "dog_kennels", "gold": "SELECT max(charge_amount) FROM Charges", "question": "How much does the most expensive charge type costs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: We need to find the most expensive charge type, so we should select the charge amount from the Charges table and sort it in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need the charge amount from the Charges table, we only need to use the Charges table.\n\n<3> SQL Generation: We can use the 'SELECT' statement to select the maximum charge amount from the Charges table and order it in descending order. Then, we can use the 'LIMIT' clause to only retrieve the first row, which will give us the most expensive charge type.\n\n", "predict": "SELECT charge_amount FROM Charges ORDER BY charge_amount DESC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT max(charge_amount) FROM Charges", "question": "What is the charge amount of the most expensive charge type?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most expensive charge type. Secondly, we need to retrieve the charge amount associated with that charge type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'Charges' table to retrieve the charge amount and the 'charge_type' column to identify the most expensive charge type.\n\n<3> SQL Generation: We can use the 'MAX' function to find the maximum charge amount in the 'Charges' table. Then, we can use a subquery to retrieve the charge type associated with that maximum charge amount. Finally, we can select the charge amount from the 'Charges' table based on the retrieved charge type.\n\n", "predict": "SELECT charge_amount FROM Charges WHERE charge_type = (SELECT charge_type FROM Charges ORDER BY charge_amount DESC LIMIT 1)"}, {"db_id": "dog_kennels", "gold": "SELECT email_address ,  cell_number ,  home_phone FROM professionals", "question": "List the email, cell phone and home phone of all the professionals.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use the table 'Professionals'.\n\n<2> SQL Generation: We need to select the 'email_address', 'cell_number', and 'home_phone' columns from the 'Professionals' table.\n\n", "predict": "SELECT email_address, cell_number, home_phone FROM Professionals"}, {"db_id": "dog_kennels", "gold": "SELECT email_address ,  cell_number ,  home_phone FROM professionals", "question": "What are the email, cell phone and home phone of each professional?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the email, cell phone, and home phone of each professional, we need to use the 'Professionals' table.\n\n<2> SQL Generation: We can simply select the 'email_address', 'cell_number', and 'home_phone' columns from the 'Professionals' table.\n\n", "predict": "SELECT email_address, cell_number, home_phone FROM Professionals"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to select the first name of all the professionals from the 'Professionals' table. Secondly, we need to join the 'Treatments' table with the 'Treatment_Types' table and select the description of the treatment for each professional.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Professionals', 'Treatments', 'Treatment_Types'].\n\n<3> SQL Generation: We need to join the 'Professionals' table with the 'Treatments' table on the 'professional_id' column. Then, we join the 'Treatments' table with the 'Treatment_Types' table on the 'treatment_type_code' column. Finally, we select the 'first_name' column from the 'Professionals' table and the 'treatment_type_description' column from the 'Treatment_Types' table.\n\n", "predict": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description FROM Professionals JOIN Treatments ON Professionals.professional_id = Treatments.professional_id JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "question": "What are each professional's first name and description of the treatment they have performed?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to retrieve the first name of each professional. Secondly, we need to retrieve the description of the treatment they have performed.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. To retrieve the first name of each professional, we need to use the 'first_name' column from the 'Professionals' table. To retrieve the description of the treatment they have performed, we need to use the 'treatment_type_description' column from the 'Treatment_Types' table.\n\n<3> SQL Generation: We need to join the 'Professionals' and 'Treatments' tables on the 'professional_id' column. Then, we join the 'Treatments' and 'Treatment_Types' tables on the 'treatment_type_code' column. Finally, we select the 'first_name' column from the 'Professionals' table and the 'treatment_type_description' column from the 'Treatment_Types' table.\n\n", "predict": "SELECT T1.first_name, T2.treatment_type_description FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id JOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code"}, {"db_id": "singer", "gold": "SELECT count(*) FROM singer", "question": "How many singers are there?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the table 'singer' for this query.\n\n<2> SQL Generation: We need to count the number of rows in the 'singer' table.\n\n", "predict": "SELECT COUNT(*) FROM singer"}, {"db_id": "singer", "gold": "SELECT count(*) FROM singer", "question": "What is the count of singers?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query is asking for the count of singers, we only need to use the 'singer' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'singer' table.\n\n", "predict": "SELECT COUNT(*) FROM singer"}, {"db_id": "singer", "gold": "SELECT Birth_Year ,  Citizenship FROM singer", "question": "What are the birth year and citizenship of singers?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the birth year and citizenship of singers, we need to use the 'singer' table.\n\n<2> SQL Generation: We need to select the 'Birth_Year' and 'Citizenship' columns from the 'singer' table.\n\n", "predict": "SELECT Birth_Year, Citizenship FROM singer"}, {"db_id": "singer", "gold": "SELECT Birth_Year ,  Citizenship FROM singer", "question": "What are the birth years and citizenships of the singers?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To retrieve the birth years and citizenships of the singers, we need to use the 'singer' table.\n\n<2> SQL Generation: We need to select the 'Birth_Year' and 'Citizenship' columns from the 'singer' table.\n\n", "predict": "SELECT Birth_Year, Citizenship FROM singer"}, {"db_id": "singer", "gold": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1", "question": "What is the name of the singer with the largest net worth?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the singer with the largest net worth. Secondly, we need to retrieve the name of that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'singer' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the singer with the largest net worth, and then retrieve their name.\n\n", "predict": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1"}, {"db_id": "singer", "gold": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1", "question": "What is the name of the singer who is worth the most?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the singer with the highest net worth. Secondly, we need to retrieve the name of that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'singer' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the singer with the highest net worth, and then retrieve their name.\n\n", "predict": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1"}, {"db_id": "singer", "gold": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID", "question": "Show titles of songs and names of singers.", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To show the titles of songs and names of singers, we need to use tables ['singer', 'song'].\n\n<2> SQL Generation: We need to select the 'Title' column from the 'song' table and the 'Name' column from the 'singer' table.\n\n", "predict": "SELECT song.Title, singer.Name FROM song JOIN singer ON song.Singer_ID = singer.Singer_ID"}, {"db_id": "singer", "gold": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID", "question": "What are the song titles and singer names?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To get the song titles and singer names, we need to use tables ['singer', 'song'].\n\n<2> SQL Generation: We simply need to select the 'Title' column from the 'song' table and the 'Name' column from the 'singer' table.\n\n", "predict": "SELECT song.Title, singer.Name FROM song JOIN singer ON song.Singer_ID = singer.Singer_ID"}, {"db_id": "real_estate_properties", "gold": "SELECT count(*) FROM Other_Available_Features", "question": "How many available features are there in total?", "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n", "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n", "types": {"Ref_Feature_Types.feature_type_code": "text", "Ref_Feature_Types.feature_type_name": "text", "Ref_Property_Types.property_type_code": "text", "Ref_Property_Types.property_type_description": "text", "Other_Available_Features.feature_id": "number", "Other_Available_Features.feature_type_code": "text", "Other_Available_Features.feature_name": "text", "Other_Available_Features.feature_description": "text", "Properties.property_id": "number", "Properties.property_type_code": "text", "Properties.date_on_market": "time", "Properties.date_sold": "time", "Properties.property_name": "text", "Properties.property_address": "text", "Properties.room_count": "number", "Properties.vendor_requested_price": "number", "Properties.buyer_offered_price": "number", "Properties.agreed_selling_price": "number", "Properties.apt_feature_1": "text", "Properties.apt_feature_2": "text", "Properties.apt_feature_3": "text", "Properties.fld_feature_1": "text", "Properties.fld_feature_2": "text", "Properties.fld_feature_3": "text", "Properties.hse_feature_1": "text", "Properties.hse_feature_2": "text", "Properties.hse_feature_3": "text", "Properties.oth_feature_1": "text", "Properties.oth_feature_2": "text", "Properties.oth_feature_3": "text", "Properties.shp_feature_1": "text", "Properties.shp_feature_2": "text", "Properties.shp_feature_3": "text", "Properties.other_property_details": "text", "Other_Property_Features.property_id": "number", "Other_Property_Features.feature_id": "number", "Other_Property_Features.property_feature_description": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we need to count the total number of available features, we only need to use the 'Other_Available_Features' table.\n\n<2> SQL Generation: We can use the 'count' function to count the number of rows in the 'Other_Available_Features' table.\n\n", "predict": "SELECT count(*) FROM Other_Available_Features"}, {"db_id": "real_estate_properties", "gold": "SELECT T2.feature_type_name FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2 ON T1.feature_type_code  =  T2.feature_type_code WHERE T1.feature_name  =  \"AirCon\"", "question": "What is the feature type name of feature AirCon?", "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n", "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n", "types": {"Ref_Feature_Types.feature_type_code": "text", "Ref_Feature_Types.feature_type_name": "text", "Ref_Property_Types.property_type_code": "text", "Ref_Property_Types.property_type_description": "text", "Other_Available_Features.feature_id": "number", "Other_Available_Features.feature_type_code": "text", "Other_Available_Features.feature_name": "text", "Other_Available_Features.feature_description": "text", "Properties.property_id": "number", "Properties.property_type_code": "text", "Properties.date_on_market": "time", "Properties.date_sold": "time", "Properties.property_name": "text", "Properties.property_address": "text", "Properties.room_count": "number", "Properties.vendor_requested_price": "number", "Properties.buyer_offered_price": "number", "Properties.agreed_selling_price": "number", "Properties.apt_feature_1": "text", "Properties.apt_feature_2": "text", "Properties.apt_feature_3": "text", "Properties.fld_feature_1": "text", "Properties.fld_feature_2": "text", "Properties.fld_feature_3": "text", "Properties.hse_feature_1": "text", "Properties.hse_feature_2": "text", "Properties.hse_feature_3": "text", "Properties.oth_feature_1": "text", "Properties.oth_feature_2": "text", "Properties.oth_feature_3": "text", "Properties.shp_feature_1": "text", "Properties.shp_feature_2": "text", "Properties.shp_feature_3": "text", "Properties.other_property_details": "text", "Other_Property_Features.property_id": "number", "Other_Property_Features.feature_id": "number", "Other_Property_Features.property_feature_description": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Other_Available_Features', 'Ref_Feature_Types'].\n\n<2> SQL Generation: We need to select the 'feature_type_name' column from the 'Ref_Feature_Types' table where the 'feature_name' column in the 'Other_Available_Features' table is 'AirCon'.\n\n", "predict": "SELECT feature_type_name FROM Ref_Feature_Types WHERE feature_type_code = (SELECT feature_type_code FROM Other_Available_Features WHERE feature_name = 'AirCon')"}, {"db_id": "real_estate_properties", "gold": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code", "question": "Show the property type descriptions of properties belonging to that code.", "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n", "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n", "types": {"Ref_Feature_Types.feature_type_code": "text", "Ref_Feature_Types.feature_type_name": "text", "Ref_Property_Types.property_type_code": "text", "Ref_Property_Types.property_type_description": "text", "Other_Available_Features.feature_id": "number", "Other_Available_Features.feature_type_code": "text", "Other_Available_Features.feature_name": "text", "Other_Available_Features.feature_description": "text", "Properties.property_id": "number", "Properties.property_type_code": "text", "Properties.date_on_market": "time", "Properties.date_sold": "time", "Properties.property_name": "text", "Properties.property_address": "text", "Properties.room_count": "number", "Properties.vendor_requested_price": "number", "Properties.buyer_offered_price": "number", "Properties.agreed_selling_price": "number", "Properties.apt_feature_1": "text", "Properties.apt_feature_2": "text", "Properties.apt_feature_3": "text", "Properties.fld_feature_1": "text", "Properties.fld_feature_2": "text", "Properties.fld_feature_3": "text", "Properties.hse_feature_1": "text", "Properties.hse_feature_2": "text", "Properties.hse_feature_3": "text", "Properties.oth_feature_1": "text", "Properties.oth_feature_2": "text", "Properties.oth_feature_3": "text", "Properties.shp_feature_1": "text", "Properties.shp_feature_2": "text", "Properties.shp_feature_3": "text", "Properties.other_property_details": "text", "Other_Property_Features.property_id": "number", "Other_Property_Features.feature_id": "number", "Other_Property_Features.property_feature_description": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the property type descriptions of properties belonging to a specific code. So, we need to filter properties based on their property type code and select the property type descriptions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Properties', 'Ref_Property_Types'] to filter properties based on their property type code and select the property type descriptions.\n\n<3> SQL Generation: We need to join the 'Properties' and 'Ref_Property_Types' tables on the 'property_type_code' column. Then, we filter the rows where the property type code matches the specified code. Finally, we select the property type descriptions from the 'Ref_Property_Types' table.\n\n", "predict": "SELECT Ref_Property_Types.property_type_description FROM Properties JOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code WHERE Properties.property_type_code = [specified code]"}]